# AdditionalProperties added to swagger for Record<unknown> property
## question 
Hi, I am trying to convert existing APIs (released to customers) to be generated from TypeSpec. The initial Swagger contained Record<unknown>, and I would like to keep the API spec the same as before. The new generated Swagger now contains an empty additionalProperties property. How can I avoid adding this additionalProperties in the Swagger?
 
Here is the generated swagger:
```
    "ArmTemplateInfo": {
      "type": "object",
      "description": "Information about a generated ARM template.",
      "properties": {
        "template": {
          "type": "object",
          "description": "The template's contents.",
          "additionalProperties": {}
        },
        "parameters": {
          "type": "object",
          "description": "The parameters of the ARM template.",
          "additionalProperties": {}
        }
      }
    },
```
 Here is how the original swagger looked:
```
    "ArmTemplateInfo": {
      "description": "Information about a generated ARM template.",
      "type": "object",
      "properties": {
        "template": {
          "description": "The template's contents.",
          "type": "object"
        },
        "parameters": {
          "description": "The parameters of the ARM template.",
          "type": "object"
        }
      }
    },
```
Here is the model:
```
model ArmTemplateInfo {
  /**
   * The template's contents.
   */
  #suppress "@azure-tools/typespec-azure-resource-manager/arm-no-record" "For backward compatibility"
  template?: Record<unknown>;

  /**
   * The parameters of the ARM template.
   */
  #suppress "@azure-tools/typespec-azure-resource-manager/arm-no-record" "For backward compatibility"
  parameters?: Record<unknown>;
}
```
PR link: https://github.com/Azure/azure-rest-api-specs/pull/35346

## answer
this is an accurate equivalent, do not try to make the swagger match exactly here
 
that property should either be `Record<unknown` or `unknown` depending on what was the target. Either way it won't produce the exact same swagger

# Issue with LongRunningResourceCreateWithServiceProvidedName operation

## question 
When I create an operation like this:
```
@pollingOperation(AiWorkflowRuns.getAiWorkflowRun)
createOrReplaceRun is StandardOperations.LongRunningResourceCreateWithServiceProvidedName<AiWorkflowRun>;
```
I get this warning:
@azure-tools/typespec-azure-core/polling-operation-no-ref-or-link
An operation decorated with '@pollingOperation' must either return a response with an 'Operation-Location' header that will contain a runtime link to the polling operation, or specify parameters and return type properties to map into the polling operation parameters. A map into polling operation parameters can be created using the '@pollingOperationParameter' decorator
It seems that `LongRunningResourceCreateWithServiceProvidedName` emits a `Location` header instead the required `OperationLocation`. How can I fix the issue?

## answer
The issue was that using LongRunningResourceCreateWithServiceProvidedName triggered a warning due to the absence of an Operation-Location header, which is required by the @pollingOperation decorator.

The resolution is to add the correct response header using a ResponseHeadersTrait. Specifically, you can include:

```
Traits = ResponseHeadersTrait<{
  ...Foundations.LongRunningStatusLocation;
}>
```
This ensures the response includes the Operation-Location header, satisfying the requirements of the @pollingOperation decorator. As confirmed in the discussion, “this template is meant to return a 201 response, and the simplest way to add the correct response is using a ResponseHeadersTrait.”

Additionally, while the REST API guidelines recommend using long-running PUT instead of POST for create operations, in this case POST is preferred because replacing a run doesn’t apply. The resource action pattern makes more sense here, especially since the run is not a proper child resource and has limited operations (get/list/cancel).

# Does it make sense for a put operation with Location header?

## question 
This is an [example](https://github.com/Azure/azure-rest-api-specs/blob/5f272067844826380939c0b3f24ca3cc99dbe308/specification/storage/resource-manager/Microsoft.Storage/stable/2024-01-01/storageTaskAssignments.json#L60-L92). Pay attention to `"final-state-via": "azure-async-operation"` and 202 response with a `Location` header. I cannot transform it into TypeSpec. How could we handle this operation?

## answer
For everyone on the channel,  such an operation doesn't make sense.  No one should write an ARM put operation that returns a 202, it is in violation of the ARM RPC.
 
I believe that you are talking about how to model an existing brownfield operation that violates the RPC without breaking.
 
Yes, it is possible to do this, [as in this playground](https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCn3mAPNB6AD16wEOIOgCMOQAyG1vZGVsIEVtcGxveWVlIGlzIFRyYWNrZWToAII8yBxQcm9wZXJ0aWVzPuUBJC4u6QCm5AHWUGFyYW1ldGVyyTE%2BO%2BgAhslfcMlE0nzKYOkBg0FnZSBvZiBlyD%2FlAXhhZ2U%2FOiBpbnQzMjsKxylDaXR50ipjaXR5Pzogc3Ry5QLpxyxQcm9maWzTWUBlbmNvZGUoImJhc2U2NHVybCLkAWBwxjA%2FOiBieXRlc8lIVGhlIHN0YXR1c8RLdGhlIGxhc3Qg5ADFYXRpb27lAvwgIEB2aXNpYmlsaXR5KExpZmVjeWNs5AHgYWTHXcQg5QOLU3RhdMRn5QGrzBTpAUjEc8wy5QCA5QDKYekB1cV3QGxyb8Q7dXMKdW7kArLRVOUBZOYBGizsANLIRyBjcmXEJ3JlcXVlc3QgaGFzIGJlZW4gYWNjZXB0ZWTEZyAgQccOOiAiyAsi1lBpxEDkALTpAMHIROwAnDogIswP2kx1cGRhdMRPxUNVxw46ICLIC8o76QSl6QDE5gDcZOcBolN1Y2NlZWTlAMXJDNM%2FxTbkAU1mYWlsyT5GxQ06ICLGCdw4d2FzIGNhbmNlyj5Dxw%2FkBP3HC%2F8BQCBkZWxl6QGARMQN5gD5yAsi6QP96QN3bW926gHK6QN5TW92ZVLHFegDcsRzbW92xGhmcm9tIGxvY%2BYAvMVuxBPxA1DLM3RvzzF0b8ov9wCVc3BvbnPrBIvmAJbHFuwAl%2B4DbMU%2BxWTGfOYC7s1uaW50ZXJm5AYcT%2BgDlHMgZXh0ZW5kc%2FYG3i7LKXt9CuUGusgjyhvLWegAzeYEs2dldOQBp0HKNeQD5%2BwFEOcEruYDW2Fu7wSBI3N1cHByZXNz%2Fwfv7wfvL2FybS1wdXQt6QR7xCPlAUEt5ATRcyLnBm7oAJbmAIBPcuUDK2Uo6ACg5QaVcHV05AU6zSLlANX1ATBGb3Vu5ANv5AaOQXJtx1noAIc8CiAgIOkDCEluc3TkAuPpBilzxiAg6QFGLMcQ32xucy5EZWZhdWx0QmFzzE%2FISD7FSD7GT85dQXJt6ASoTHJv6AJoPExyb0hlYWRlcnMgPcUkc3luY%2BkAyMYbPEZpbmFsUmVzdWx0ID3JWD4gJugAt3JtTHJvTOcDAd81yTXpCXjtAOFSZXRyeUFmdGVyxkjoAM1ycm9y6AC2CiAg5QJT5QUL5gGlcm1DdXN0b21QYXRjaFN5bmPmAWPvAQT%2FAV%2FEfsYc5gH%2FTeQDmPgBrPIHvsUZ5AGD5QCd5gSu7wMX5QSrZVdpdGhvdXRPa%2BUBbu4DJ2xpc3RCecgwR3JvdXDPREzFIlBhcmVudNQ8U3Vic2NyaXDlBI3GO8YzzBnMOegIdCBzYW1wbOsFemFjxUR0aGF05gR36QO2dG8gZGlmZmXkAITvBPrFKe4AskHFSOUBlsh3LOwFhcgN5gHe8wCSSEVBROoIYMR%2BY2hlY2vqAKpleGlzdGVu5gnaIMYeRckU7gCOQ80d7gm1&e=%40azure-tools%2Ftypespec-autorest&options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%2C%22options%22%3A%7B%22%40azure-tools%2Ftypespec-autorest%22%3A%7B%22emit-lro-options%22%3A%22all%22%7D%7D%7D).  But this should only be done in a brownfield conversion to prevent breaking changes to the API.  You should also be completely sure that your API actually behaves this way - client SDKs can be very flexible in resolving lros, and the flexibility of the SDKs may hide an error in your api specification
The current lro mechanism is designed to allow multiple pathways to resolve the lro, and to select one as the 'favored pathway' for clients - in general we should describe what the service does and make sure that we give our clients the right information.
 
We will be working on standardizing what new services do.

# Will changing the delete method on a tracked resource be a breaking change?

## question 
We were trying to add cascade delete support to our tracked resource, which means we need to change the delete operation to be an async operation.  I tried to version it out so that it wouldn't try to change the preview version of the API that has already been pushed to the public repo, but it seems I can't since it knows both delete operations would be routed the same regardless of what I've named them
```
/**
 * The operation to delete a firmware analysis workspace.
 */

@added(Versions.v2025_07_01)
delete is ArmResourceDeleteWithoutOkAsync<Workspace>;    
Duplicate operation "delete" routed at "delete /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTFirmwareDefense/workspaces/{workspaceName}".

@removed(Versions.v2025_07_01)
deleteSync is ArmResourceDeleteSync<Workspace>;    
Duplicate operation "deleteSync" routed at "delete /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTFirmwareDefense/workspaces/{workspaceName}".
```
Does anyone have any advice for how I can accomplish what I'm trying to do or do I need to go through the breaking change process for this? Can I just change the response type to be async and it's just fine?

## answer
using this `@removed/@renamedFrom` trick on the old operation, with `@added` on the new operation and  both using `@sharedRoute` works for this

# Can required fields have default values?

## question 
Does typespec allow default value for required field? I ask as mandatory field states that users send a value but we want to be able to assign a default for them. The field is below. 
```
model StorageDiscoveryWorkspaceProperties {
  @doc("The storage discovery sku.")
  @renamedFrom(ApiVersion.v2025_03_01_preview, "tier")
  @madeRequired(ApiVersion.v2025_06_01_preview)
  sku: StorageDiscoverySku;
```

## answer
Can required fields have default values in TypeSpec?

Unfortunately, TypeSpec does not currently support versioned default values for required fields. If you want to assign a default value to a required field, you’ll need to use the “remove/rename dance” workaround, as shown in the referenced playground. This means you’ll have to remove the old field and reintroduce it with a default value, which is not ideal but currently the only way.

Can we delete unused preview versions and only keep the latest one?

Yes, absolutely. That is what we recommend. Azure services are moving toward maintaining only one active preview version per spec (except for ARM retention requirements, which typically apply only to public previews). Since you’re still in private preview and none of your previous versions are being used, you can safely remove them and keep only the latest one.

Deprecation only matters if you have customers using those versions. For private previews, there are no SDK support requirements. You can simply remove the older versions from your TypeSpec.

What’s the process for moving to public preview?

You should open a PR against the public repo’s main branch before the public preview announcement. You can start preparing Microsoft Learn documentation using the versions merged in the RPSaaSMaster branch. The review process for public preview is slightly easier if you’ve already been reviewed privately, but it does include required SDK checks.

You should only bring over the latest preview version to the public repo. It’s fine to omit .tsp files in the public repo if they’re not needed.

# ARM PR Typespec validation - GitHub CI fails but succeeds locally

## question 
I'm new to Typespec and the only one from my team to try it, so I have no one else to turn to for what I believe is a rookie mistake in my Typespec PR. In my PR (https://github.com/Azure/azure-rest-api-specs/pull/34972) the Typespec validation fails where running `npm exec --no -- tsv specification/nginx/Nginx.Management` returns errors. But when I run this same command locally on my IDE, it succeeds:
```
execFile("C:\\nvm4w\\nodejs\\node.exe", ["--" "C:\\nvm4w\\nodejs\\node_modules\\npm\\bin\\npm-cli.js", "exec", "--no-ttier", "--write","tspconfig.yaml"])
    simple-git [GitExecutor] [SPAWN] git ['status', '--porcelain', '-b', '-u', '--null', '--porcelain', 'C:/Users/briankimutai/source/repos/azure-rest-api-specs/specification/nginx'] +0ms
    simple-git [GitExecutor] [HANDLE] retrieving task output complete +522ms
tspconfig.yaml 306ms (unchanged)
Running git diff on folder C:/Users/briankimutai/source/repos/azure-rest-api-specs/specification/nginx

Executing rule: SdkTspConfigValidation
[SdkTspConfigValidation]: validation passed.

PS C:\Users\briankimutai\source\repos\azure-rest-api-specs>
```
I believe I'm making a rookie mistake and would appreciate if someone could point it out and unblock us

## answer
The reason your TypeSpec validation fails in GitHub CI but succeeds locally is due to a case sensitivity mismatch in your folder naming. Your PR uses NGINX.NGINXPLUS as the RP namespace directory, but the validation check expects Nginx.NginxPlus. Git repositories are case-sensitive, and this discrepancy causes the CI to fail.

To fix this, you have two options:

Rename your folder and TypeSpec namespace to match Pascal casing (Nginx.NginxPlus), which is the recommended convention. However, this may trigger validation errors if older API versions are not present in main, as the spec will be treated as new and require rewriting in TypeSpec.

Keep using NGINX.NGINXPLUS if that’s what your spec has historically used. You can suppress the TypeSpec linter warning and configure the output path in your TypeSpec config like this:
```
output-file: "{azure-resource-provider-folder}/NGINX.NGINXPLUS/{version-status}/{version}/openapi.json"
```
This way, you avoid rewriting older versions and maintain consistency with your existing structure.

# How to update any model without affecting old API versions

## question 
Hi team, 
 
I have a model in the v2_preview version, and now with the new v3_preview version, I want to update a pattern and add some additional fields. Could anyone advise on the best approach to make these updates in the new version without impacting the old version?
 
Example:
```
OLD:
@doc("The Branch resource type.")
@added(Neon.Postgres.Versions.v2_preview)
@parentResource(Project)
model Branch is ProxyResource<BranchProperties> {
  ...ResourceNameParameter<
    Resource = Branch,
    KeyName = "branchName",
    SegmentName = "branches",
    NamePattern = "^\\S.{0,62}\\S$|^\\S$"
  >;
}

Updated:

@doc("The Branch resource type.")
@added(Neon.Postgres.Versions.v2_preview)
@parentResource(Project)
model Branch is ProxyResource<BranchProperties> {
  ...ResourceNameParameter<
    Resource = Branch,
    KeyName = "branchName",
    SegmentName = "branches",
    <span style="background-color:#DF9299">NamePattern = </span>"<span style="background-color:#DF9299">^\\S.{0,126}\\S$|^\\S$</span>"
  >;
}
```

## answer
To update a model in a new API version without affecting the old one, especially when changing a pattern or adding fields, the challenge is that decorator contents (like NamePattern) are not versioned in TypeSpec. So, modifying them directly will affect all versions.

There are two main approaches:

Workaround with a new model: You can create a new model with a different name and use @renamedFrom, but this leads to a cascade of renames across operations, which is not ideal.

Apply the change across all versions: If the new regex is backwards compatible, and the change reflects how the service actually behaves across all versions, then it’s appropriate to update the existing model and apply the change to all API versions. This avoids inconsistencies and unnecessary duplication.

In practice, name validation changes usually apply across all versions, so updating the shared model is acceptable. Just be aware that this may be considered a breaking change depending on your service’s governance, and you might need approval.

# Need help with PR checks

## question 
Hi, need help with some failures I'm getting when running a PR against `azure-api-specs-pr`. This is the PR: [Microsoft Planetary Computer Pro - AI Workflows by emiliodangelo · Pull Request #23267 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/23267) and I'm getting the following errors when running the PR checks:
`private.rest-api-specs-pr`: Failing with the message `the branch is protected`, [Microsoft Planetary Computer Pro - AI Workflows by emiliodangelo · Pull Request #23267 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/23267/checks?check_run_id=44598442126). I assume this is expected since the PR is against the main branch of the private repo.
`private.rest-api-specs-pr (BranchProtectionForPrivateRepo)`: Same error as above.
`Swagger ModelValidation`: Fails with error `unacceptable kind of an object to dump [object Error]`, [Microsoft Planetary Computer Pro - AI Workflows by emiliodangelo · Pull Request #23267 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/23267/checks?check_run_id=44598262948).
`Swagger SemanticValidation`: Failing with `INTERNAL_ERROR`, part of the message is `Must have text between two parameters, missing text after "2x" at safePattern`, [Microsoft Planetary Computer Pro - AI Workflows by emiliodangelo · Pull Request #23267 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/23267/checks?check_run_id=44598263149).
`Swagger LintDiff`: Fails with `AvoidAnonymousTypes`, [Microsoft Planetary Computer Pro - AI Workflows by emiliodangelo · Pull Request #23267 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/23267/checks?check_run_id=44598262474).
The `Swagger LintDiff` seems to be related with this question: [Emilio D'Angelo: Asynchronous resource delete | Azure SDK > TypeSpec Discussion | Microsoft Teams](https://teams.microsoft.com/l/message/19:906c1efbbec54dc8949ac736633e6bdf@thread.skype/1750334021292?tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47&groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&parentMessageId=1750334021292&teamName=Azure%20SDK&channelName=TypeSpec%20Discussion&createdTime=1750334021292).
The error appears when using this pattern:
```
@resource("operations")
@added(Versions.v2025_09_30_Preview)
@doc("An AI Workflow delete operation.")
model AiWorkflowOperationStatus is Foundations.OperationStatus<never>;

@tag("AI Workflows")
@route("ai")
@added(Versions.v2025_09_30_Preview)
interface AiWorkflowOperations {
  get is StandardOperations.ResourceRead<AiWorkflowOperationStatus>;
}

@tag("AI Workflows")
@route("ai")
@added(Versions.v2025_09_30_Preview)
interface AiWorkflows {
  ...

  @pollingOperation(AiWorkflowOperations.get)
  delete is StandardOperations.LongRunningResourceDelete<AiWorkflow>;

  ...
}
```

## answer
The issue you're encountering is caused by a regression in the path-to-regexp dependency used by oav. Specifically, patterns like {width}x{height} or {x}/{y}@{scale}x in your API paths are now breaking validation due to stricter parsing rules introduced in path-to-regexp@6.2.1.

Previously, your spec passed validation because older versions of path-to-regexp were more lenient. The recent update introduced security fixes that inadvertently caused this break.

To unblock your PR, we’ve deployed a temporary fix that pins path-to-regexp to an older version. This means your Swagger checks should no longer crash. Meanwhile, we’re working on a permanent solution that doesn’t rely on pinning old code.

If you still need to validate locally, you can manually install the older version and run oav like this:
```
<install node 20>
mkdir testdirectory
cd testdirectory
npm i oav path-to-regexp@6.2.2
npx oav validate-example /path/to/your/openapi.json
```
Alternatively, you can use validate-spec instead of validate-example if you're checking the spec directly. This workaround has been confirmed to pass for your PR.

We’ve also applied the approved-modelvalidation and approved-semanticvalidation labels to your PR to unblock progress. Just note that if other issues surface later due to this regression, you may need to address them in a follow-up PR.

# Parameterizing @doc through interface value params

## question 
Hi, I'm trying to parameterize an interface doc decorator but running into an issue:
```
const DeploymentStackCommonOpDefaultParams: Record<string> = #{
  ScopeName: "resource scope" // resource group, subscription, etc
};

// Generic interface for common DeploymentStack operations
// For some reason, the ArmResourceActionAsync type requires the base params extends this reflection model type.
interface DeploymentStackCommonOps<TBaseParams extends TypeSpec.Reflection.Model, VCommonOpsParams extends valueof Record<string> = DeploymentStackCommonOpDefaultParams> {
  /**
   * Gets a Deployment stack with a given name at the specified scope.
   */
  @doc("Gets a Deployment stack with the given name in the {ScopeName}", VCommonOpsParams)   
  get is ArmResourceRead<DeploymentStack, BaseParameters = TBaseParams>;
```
I'm getting diagnostics:
```
Argument of type 'VCommonOpsParams' is not assignable to parameter of type '{}'TypeSpec(invalid-argument)
Argument of type '#{ScopeName: "resource group"}' is not assignable to parameter of type '{}'TypeSpec(invalid-argument)
Argument of type 'unknown' is not assignable to parameter of type '{}'TypeSpec(invalid-argument)
Argument of type 'unknown' is not assignable to parameter of type '{}'TypeSpec(invalid-argument)
```
Am I misunderstanding how to use this or how can I accomplish this?

## answer
The parameter you're referring to is a legacy feature. It doesn't behave as you might expect—it only interpolates internal properties of the type passed and is currently used exclusively for interpolating model names in templates.

Today, you cannot create an option bag or pass a model as a parameter to interpolate multiple values. Instead, you should interpolate individual values directly using ${}.

Also, accessors on values or templates are not supported in TypeSpec. So expressions like ${VSomeModelValue.scopeName} won’t work. If you try to pass a model and access its properties, you'll get errors like:

Argument of type 'string' is not assignable to parameter of type 'valueof string'
Cannot resolve 'scopeName' in node TemplateParameterDeclaration since it has no members. Did you mean to use "::" instead of "."?
So for now, the best approach is to pass each value separately as a string and interpolate them individually.

# Avocado error after @renamedFrom on custom action route

## question 
For PR [Add Microsoft.Mission version 2025-05-01-preview - Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/22581) I was asked to consider renaming routes for some custom actions to meet naming conventions. For example, I now have this in my routes:
```
@doc("Community Endpoint Interface")
@armResourceOperations
interface CommunityEndpoints {
  @doc("Callback that triggers on approval state change.")
  @armResourceAction(CommunityEndpointResource)
  @added(Microsoft.Mission.Versions.v2024_12_01_preview)
  @renamedFrom(
    Microsoft.Mission.Versions.v2025_05_01_preview,
    "approvalCallback"
  )
  notifyOnApprovalCreation is ArmResourceActionAsync<
    CommunityEndpointResource,
    ApprovalCallbackRequest,
    ApprovalActionResponse
  >;
}
```
This unfortunately now produces Avocado errors for [MISSING_APIS_IN_DEFAULT_TAG](https://github.com/Azure/avocado/blob/master/README.md#MISSING_APIS_IN_DEFAULT_TAG) , 

The default tag should contain all APIs. The API path 
```
/subscriptions/{}/resourcegroups/{}/providers/microsoft.mission/virtualenclaves/{}/enclaveendpoints/{}/approvalcallback
```
is not in the default tag. Please make sure the missing API swaggers are in the default tag.
readme: [specification/mission/resource-manager/readme.md](https://github.com/Azure/azure-rest-api-specs-pr/blob/589a07c8dcfe05714c746dcaf2052da06ae6ad74/specification/mission/resource-manager/readme.md)
json: [Microsoft.Mission/preview/2024-12-01-preview/openapi.json](https://github.com/Azure/azure-rest-api-specs-pr/blob/589a07c8dcfe05714c746dcaf2052da06ae6ad74/specification/mission/resource-manager/Microsoft.Mission/preview/2024-12-01-preview/openapi.json)

Is there something that I need to do differently to define this route renaming?
 
Link to [Avocado check](https://github.com/Azure/azure-rest-api-specs-pr/pull/22581/checks?check_run_id=45066798540). Thanks!

## answer
Avocado doesn't handle moves/renames.  You can suppress by adding label `Approved-Avocado`.

# Operation Id update

## question 
Is there a way to update operation id for Operations extended from Azure.ResourceManager.Operations? We had released operations API with a operation id as ProviderOperations_List instead of Operations_List and this causes a breaking changes in swagger for our typespec conversion PR.
https://github.com/Azure/azure-rest-api-specs/pull/35346/checks?check_run_id=45063413468

## answer
just name the interface [ProviderOperations](https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCn3mAPNB6AD16wEOIOgCMOQAyG1vZGVsIEVtcGxveWVlIGlzIFRyYWNrZWToAII8yBxQcm9wZXJ0aWVzPuUBJC4u6QCm5AHWUGFyYW1ldGVyyTE%2BO%2BgAhslfcMlE0nzKYOkBg0FnZSBvZiBlyD%2FlAXhhZ2U%2FOiBpbnQzMjsKxylDaXR50ipjaXR5Pzogc3Ry5QLpxyxQcm9maWzTWUBlbmNvZGUoImJhc2U2NHVybCLkAWBwxjA%2FOiBieXRlc8lIVGhlIHN0YXR1c8RLdGhlIGxhc3Qg5ADFYXRpb27lAvwgIEB2aXNpYmlsaXR5KExpZmVjeWNs5AHgYWTHXcQg5QOLU3RhdMRn5QGrzBTpAUjEc8wy5QCA5QDKYekB1cV3QGxyb8Q7dXMKdW7kArLRVOUBZOYBGizsANLIRyBjcmXEJ3JlcXVlc3QgaGFzIGJlZW4gYWNjZXB0ZWTEZyAgQccOOiAiyAsi1lBpxEDkALTpAMHIROwAnDogIswP2kx1cGRhdMRPxUNVxw46ICLIC8o76QSl6QDE5gDcZOcBolN1Y2NlZWTlAMXJDNM%2FxTbkAU1mYWlsyT5GxQ06ICLGCdw4d2FzIGNhbmNlyj5Dxw%2FkBP3HC%2F8BQCBkZWxl6QGARMQN5gD5yAsi6QP96QN3bW926gHK6QN5TW92ZVLHFegDcsRzbW92xGhmcm9tIGxvY%2BYAvMVuxBPxA1DLM3RvzzF0b8ov9wCVc3BvbnPrBIvmAJbHFuwAl%2B4DbMU%2BxWTGfOYC7s1uaW50ZXJm5AYc6AT9T%2BgDnHMgZXh0ZW5kc%2FYG5i7LKXt9Cg%3D%3D&e=%40azure-tools%2Ftypespec-autorest&options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D) instead and suppress the warning

# SDK Validation failing for Python

## question 
Hi, we're trying to add a new API version for Key Vault's data-plane libraries and are seeing unexpected SDK validation failures for Python. The PR is [#35534](https://github.com/Azure/azure-rest-api-specs/pull/35534) and the [pipeline failure is here](https://dev.azure.com/azure-sdk/public/_build/results?buildId=5030670&view=logs&j=83516c17-6666-5250-abde-63983ce72a49&t=00be4b52-4a63-5865-8e02-c61723ad0692&s=6884a131-87da-5381-61f3-d7acc3b91d76).
 
The error just states that `generateOutput.json` doesn't exist, which I assume is because the generation failed. What's odd is that I can generate the [azure-keyvault-securitydomain](https://github.com/Azure/azure-sdk-for-python/tree/main/sdk/keyvault/azure-keyvault-securitydomain) package with `tsp-client update` just fine locally -- it's also odd that this is the only KV TSP project with this failure, when other Python KV libraries are generated with TSP. Can anyone help diagnose the issue here? Thanks!

## answer
I think the real errors start here.  Did you find this already?
 
https://dev.azure.com/azure-sdk/public/_build/results?buildId=5031263&view=logs&j=83516c17-6666-5250-abde-63983ce72a49&t=00be4b52-4a63-5865-8e02-c61723ad0692&l=1642
 
10:25:53.181 cmdout 	[automation_generate.sh] /mnt/vss/_work/1/s/azure-sdk-for-python/sdk/keyvault/azure-keyvault-securitydomain/TempTypeSpecFiles/Security.KeyVault.SecurityDomain/routes.tsp:5:1 - error import-not-found: Couldn't resolve import "../Security.KeyVault.Common/common.tsp"


10:25:53.181 cmdout 	[automation_generate.sh] /mnt/vss/_work/1/s/azure-sdk-for-python/sdk/keyvault/azure-keyvault-securitydomain/TempTypeSpecFiles/Security.KeyVault.SecurityDomain/routes.tsp:41:22 - error invalid-ref: Unknown identifier KeyVaultOperation

10:25:53.181 cmdout 	[automation_generate.sh] /mnt/vss/_work/1/s/azure-sdk-for-python/sdk/keyvault/azure-keyvault-securitydomain/TempTypeSpecFiles/Security.KeyVault.SecurityDomain/routes.tsp:53:15 - error invalid-ref: Unknown identifier KeyVaultOperation
10

# Parameter naming

## question 
Is there a way to update parent resource parameter name (@key) for child resource APIs? For example, I want to generate following operations for division child resource and employee parent resource
employee/{employeeName}/division/{name} 
employee/{name}

## answer
Is this a client consideration (I think service doesn't care about parameter name)? If so you could use `@clientName(your operation::parameters.name, "employeeName")`
