# Changing Property to Optional with Default

**Category: Versioning**

## question 
Hi everyone,
 
I am making a property optional in typespec and to be a non-breaking change, I see that is required to have a default. However my change seems to also change the existing version instead of only the new version.
 
Before:
  @OpenAPI.extension("x-ms-identifiers", #[])
  dnsResolverDomainLists: SubResource[];
 
After:
  @madeOptional(Versions.v2025_10_01_preview)
  @OpenAPI.extension("x-ms-identifiers", #[])
  dnsResolverDomainLists?: SubResource[] = #[];
 
1) How can I make the change in typespec so that the generation of the openapi jsons will not affect the existing version? Currently generation also adds the empty array default to the existing API version (2025-05-01) which causes the breaking change CI to flag.
2) Is there a way I can default the SubResource[] array to null instead?
 
This is in accordance to the documentation here (Made optional with/without default case): [non-breaking-versioning | TypeSpec Azure](https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/non-breaking-versioning/#-incorrect)
My PR: [Release 2025-10-01-preview for DNS Resolver by jamesvoongms · Pull Request #24470 · Azure/azure-res…](https://github.com/Azure/azure-rest-api-specs-pr/pull/24470)

## answer
You should not add OpenApi extensions directly - x-ms-identifiers are automatically added based on the `@key` properties of a model,  or you should use the `@identifiers` decorator if you need to override the default setting.
 
The problem is that this is two changes (making a property optional and providing a default), but there is only versioning decoration for one change.  Compounding this, there is no versioning decoration for adding a default value, this is being tracked here: [Add additional versioning decorators · Issue #2761 · microsoft/typespec](https://github.com/microsoft/typespec/issues/2761).  Ideally we should combine these two changes into a single decorator to promote non-breaking changes.
 
Meanwhile, you can do this using the added/removed/rename pattern to replace one property with another property in a new version, as in [this playground](https://azure.github.io/typespec-azure/playground/?options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D&c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIOQA10NvbW1vblTkAY%2FHQCj1ATcuyykuyGoudjUpCiAgYNJpYCwK6gCFNf8Ahf8Ahf8AhesAhc9pYCwKfeYBOEHoATrrAVMg6AJ15ACIbW9kZWwgRW1wbG95ZWUgaXMgVHJhY2tlZOgAgjzIHFByb3BlcnRpZXM%2B5QFpLi7pAKbkAhtQYXJhbWV0ZXLJMT476ACGyV9wyUTSfMpg6QHIQWdlIG9mIGXIP%2BUBOGFnZT86IGludDMyO%2BgBbENpdHnSKmNpdHk%2FOiBzdHLlAy7HLFByb2ZpbNNZQGVuY29kZSgiYmFzZTY0dXJsIuQBYHDGMD86IGJ5dGVzyUhUaGUgc3RhdHVzxEt0aGUgbGFzdCDkAMVhdGlvbuUDQSAgQHZpc2liaWxpdHkoTGlmZWN5Y2zkAeBhZMddxCDlA9BTdGF0xGflAavMFMVzQHJlbW926wNCLvQB%2BcRUQHJl5ANcZEZyb23eLiwgInN0dWZm5QDoQGRvYygi5gDWyBRvbGRTxA3oAUVbXeYAjGFkZP8AiuYAitNTxQrpAZZbXSA9ICPEV%2BcCK8Qt7AEV5QFj5QGtYekCuOYEm2xyb%2BQBHnVzCnVu5ANV8QE35QJHxmfpA5XEX8hHIGNyZcQncmVxdWVzdCBoYXMgYmVlbiBhY2NlcHRlZMRnICBBxw46ICLICyLWUGnEQOQAtOkAwchE7ACcOiAizA%2FaTHVwZGF0xE%2FFQ1XHDjogIsgLyjvpBc3pAMTmANxk5wKFU3VjY2VlZOUAxckM0z%2FFNuQBTWZhaWzJPkbFDTogIsYJ3Dh3YXMgY2FuY2XKPkPHD%2BQGJccL%2FwFAIGRlbGXpAYBExA3mAPnICyLpBODpBFrkAxzpAcrpBFxNb3ZlUscV6ARVxHNtb3bEaGZyb20gbG9j5gC8xW7EE%2FEEM8szdG%2FPMXRvyi%2F3AJVzcG9uc%2BsFbuYAlscW7ACX7gRPxT7FZMZ85gLuzW5pbnRlcmbkB0RP6AR3cyBleHRlbmRz9ggGLsspe30K5QfiyCPKG8tZ6ADN5gWWZ2V05AGnQco15ATK7AXzIOcCe09y5QKn5QHWyy9Dxx1SZXBsYWNlQXN5bmPOP%2BUC98g3Q3VzdG9tUGF0Y2hTxCoKICAg6QCTLMUO9gDnRm91buQDJuQEn8gc5gCRTeQBhMZJ0EvKEOoGjcUZPgogIOUAneYCmu8A1OUCl2VXaXRob3V0T2vzANRsaXN0QnnIMEdyb3Vwz0RMxSJQYXJlbnTUPFN1YnNjcmlw5QJ5xjvGM8wZzDnoB0Mgc2FtcGzrA2ZhY8VEdGhhdOYCY%2BkHBnRvIGRpZmZl5ACE7wLmxSnuALJBxUjlAZbIdyzsA3HIDeYC6PMAkkhFQUTqBy%2FEfmNoZWNr6gCqZXhpc3RlbuYIqSDGHkXJFO8CWM0d7giE&e=%40azure-tools%2Ftypespec-autorest&vs=%7B%7D).
```
/** Employee properties */
model EmployeeProperties {
  /** Age of employee */
  age?: int32;

  /** City of employee */
  city?: string;

  /** Profile of employee */
  @encode("base64url")
  profile?: bytes;

  /** The status of the last operation. */
  @visibility(Lifecycle.Read)
  provisioningState?: ProvisioningState;

  @removed(Versions.`2025-10-01-preview`)
  @renamedFrom(Versions.`2025-10-01-preview`, "stuff")
  @doc("The stuff")
  oldStuff: string[];

  @added(Versions.`2025-10-01-preview`)
  @doc("The stuff")
  stuff?: string[] = #[];
}
```

# Is TypeSpec migration complete for folder: recoveryservicesbackup.

**Category: TypeSpec Migration**

## question 
Hi TypeSpec Discussion,
 
We had PR in flight: [Adding stable 2025 08 01 for completeness by risraj10 · Pull Request #37381 · Azure/azure-rest-api-…](https://github.com/Azure/azure-rest-api-specs/pull/37381)
However, I see that TypeSpec migration was done couple of days ago for this folder.
 
I have cancelled the above PR and trying to raise a new PR. However, just running npx tsp compile without any change is giving errors.
And also it is making unintended change to OpenAPI json file even to existing version. I guess the tsp and OpenAPI json are not in sync.
Hence, wanted to check if the migration is really complete for this folder. 

## answer
Main typespec validation should always be passing are you sure you are up you are with dependencies locally?
Make sure to follow instructions here https://aka.ms/ci-fix
Just to reiterate, this is almost always because you need to pull the latest from the target branch into your local clone of the repo, and re-install dependencies at the root.
https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally
