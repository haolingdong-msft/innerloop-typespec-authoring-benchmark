# Does typespec allow negative lookaheads in name validation?

**Category: Decorators**

## question 
 Hi Team, 
Does typespec allow negative lookahead for validating names? If not can you share the limitations? 
Here is the pattern we are trying to implement:
- Length - 4 - 64
- Alphanumerics and hyphens
- Can't end with period. Start with a letter
- Can't start or end with hyphen. Can't us consecutive hyphens
- Can have spaces but not at the start or end of a name.
```
model StorageDiscoveryScope {
  @doc("Display name of the collection")
  @pattern("^(?! )[a-zA-Z0-9]+(?:[ -][a-zA-Z0-9]+)*(?<! )$")
  @minLength(4)
  @maxLength(64)
  displayName: string;
```

## answer
no, only simple syntax same as openapi. Documented on the `@pattern` decorator https://typespec.io/docs/standard-library/built-in-decorators/#@pattern
note that `@pattern` is also just documentation purpose from the point of view of SDK(it won't validate regardless), you are still free to add extra validation on your side and document those restriction in the property doc

# Unresolved Breaking changes

**Category: TypeSpec Migration**

## question 
We are under the process of resolving breaking changes in the PR raised by the conversion team, we have resolved most of them.
But some of the breaking changes reported are not possible syntactically to achieve the exact output from typespec that we have in our current swagger spec in main.
Ex : https://github.com/Azure/openapi-diff/tree/master/docs/rules/1025.md
It's not possible to introduce 'all of' in typespec. 
So will the service has to go through the complete breaking change review process for the semantically different new swagger output generated by typespec ?

## answer
Our principle is to ensure the functional equivalence. Since TypeSpec and swagger are actually two different "languages", we cannot ensure textual equivalence. The action at service's side is to ensure the TypeSpec are accurately representing service's API surface, because we don't have business knowledge. 
You could use `extends` to represent `allof`

# Is it so bad to introduce named types to replace unnamed ones?

**Category: SDK Generation**

## question 
RE [Yuxia/20250401preview by blankor1 · Pull Request #33507 · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/pull/33507#issuecomment-3029062363)
 
I notice a suppression in the typespec PR 
 
#suppress "@azure-tools/typespec-client-generator-core/no-unnamed-types" "Backwards compatibility with existing clients."
 
Sounds like the PR author is under the impression its a bad idea to get rid of unnamed types and replace them with named ones, because of concerns about backwards compatibility. Is this actually correct?
 
Or would we consider this a benign change? And a best practice to 'fix' unnamed types by creating named types to replace them?

## answer
Introducing named types to replace unnamed ones is not a bad idea—in fact, it's preferred. The linter rule @azure-tools/typespec-client-generator-core/no-unnamed-types exists to encourage naming types. However, in the PR you referenced, there was a suppression added with the justification of "Backwards compatibility with existing clients."

After reviewing the context, it seems this suppression may not be necessary. The rule itself is currently disabled due to performance issues, so removing the suppression won’t trigger CI. Conceptually, this is a false positive: the anonymous model created via @bodyRoot is a temporary structure that the SDK won’t use, so it shouldn't be flagged.

Still, the current template resolves to a borderline case where the SDK might auto-generate a name. A cleaner approach would be to use @@clientName to rename the body parameter directly, avoiding the anonymous model altogether. This is considered a better practice.

So yes—replacing unnamed types with named ones is generally a good idea, and in this case, the suppression may not be needed.