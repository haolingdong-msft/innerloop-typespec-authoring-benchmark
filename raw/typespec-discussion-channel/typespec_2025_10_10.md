# Service under conversation label

## question 
Hi TypeSpec Discussion,
 
My team currently has a PR open to release a new stable API. However, due to backend delays, it’s been open since July. During that time, the [typespec migration PR](https://github.com/Azure/azure-rest-api-specs/pull/36556) was drafted against our preview API. Now, the service-under-conversion label has been added to our stable PR. I’d like to understand does this label indicate a delay in merging in our [stable api PR](https://github.com/Azure/azure-rest-api-specs/pull/36219), or will we need to make additional changes?

## answer
The label should not impact your previous PR, and , if this is a later api-version thatn the conversion PR, the conversion would normally be based on that version once checked in.  Adding Janine Zhang for awareness about the conversion.

# What decorator should be used in this case?

## question 
Hi team,
 
In version v2, we introduced a new model model2 and updated featureA (originally added in v1) to use model2 as its parameter. In v1, featureA used model1 at the same position.
 
Here’s the setup I tried (using @typeChangedFrom):

```
@added(v1)  
model1;  

@added(v2)  
model2;  

@added(v1)  
featureA {  
  @typeChangedFrom(v1, model1)  
  body: model2;  
} 
```
However, this shows the error: "model2 does not exist in v1".
 
What would be the correct decorator to use in this situation?
 
Thank you!

## answer
it should be `typedChangedFrom(v2, model1` here otherwise you are saying in v1 you changed from using model1 to model2 which then of course doesn't exists

# Multiple default values

## question 
Is there a way to set per-language-SDK default values for a property? I've got a text encoding property that will be different across the SDKs - I can customize SDKs but curious if there's a TypeSpec way to do this.

## answer
There is not concept of client default right now at all in typespec. The default represent like in openapi the server default.
we've purposefully not allowed client default values at this point because it's not good for roundtripping.

# Can we reorder the API versions like this, and should we remove the older preview version?

## question 
Hi team,
 
We are adding 2025-11-01 GA and 2025-11-15-preview in TypeSpec.
For 2025-11-01 GA:
Adds new features feature1, feature2 compared to the last GA (2023-04-15)
Adds new models model1, model2 compared to the last GA (2023-04-15)
For 2025-05-15-preview (older preview):
Already contains feature1, feature2, plus feature3, feature4 (which we do not want to expose in 2025-11-01 GA)
Contains models model1p, model2p (corresponding to model1, model2 but with different names) and model3p, model4p (which we also do not want to expose in 2025-11-01 GA)
For 2025-11-15-preview (new preview):
Should align naming with 2025-11-01 GA
Includes feature1, feature2, feature3, feature4
Includes model1, model2, model3p, model4p
To simplify in TypeSpec, I think the easiest approach is to place GA versions together, since between GA releases we only need @added. Otherwise, we’d have to @remove from the older preview and then @add the not-exposed features/models again in the new preview.
So can we order the versions in enum Versions like:
2023-04-15, 2025-11-01, 2025-05-15-preview, 2025-11-15-preview
This way, feature/model additions and renamings are handled more straightforwardly.
 
One more question: should we remove the older preview once we add a newer preview? For example, in this case, would we remove 2025-05-15-preview, keeping only 2023-04-15, 2025-11-01, and 2025-11-15-preview?
Thank you so much!

## answer
the current policy is to have a single preview version for Azure services. So removing the old preview and replacing the new one is the correct approach. However I do think you'll also need to delete the swagger for the CI to pass

# Versioning the LRO headers

## question 
I am reaching out to seek advice about versioning the LRO header:
 
My PR: [Define contract for Batch RuleSet feature by mangoo1 · Pull Request #37879 · Azure/azure-rest-api-s…](https://github.com/Azure/azure-rest-api-specs/pull/37879)
is about to extend an existing RuleSet PUT endpoint to allow it accepting an optional request body, the feature would be turned on when we specify a bool flag to true and the PUT endpoint would be extend to 201 LRO. 
 
This behavior would be available on the new ApiVersion, so I would like to put the Azure.Core.useFinalStateVia annotation to the new ApiVersion, along with LRO/Async headers ArmAsyncOperationHeader<FinalResult = RuleSet> and ArmLroLocationHeader<FinalResult = RuleSet>.  But I still won't be able to find a way to put the @added(version) annotations to them. 
 
Can I version the operation to achieve this?  [Versioning | TypeSpec](https://typespec.io/docs/getting-started/getting-started-rest/06-versioning/#version-specific-operations)
 
What would be the recommended way to do this?
(1.The original put request doesn't have a request body, so I make the put request body optional for backwards compatibility.
2.There is an optional bool flag in the optional request body to turn the feature requires LRO ON.)

## answer
here's a [playground](https://azure.github.io/typespec-azure/playground/?options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D&c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjUtMTAtMDEtcHJldmlld8g1xDQgIOQA10NvbW1vblTkAY%2FHQCj1ATcuyykuyGoudjUpCiAgYNJpYCwK8ACFN%2F8Ahf8Ahf8AhesAhclpYCwKfeYBOEHoATrrAVMg6AJ15ACIbW9kZWwgRW1wbG95ZWUgaXMgVHJhY2tlZOgAgjzIHFByb3BlcnRpZXM%2B5QFpLi7pAKbkAhtQYXJhbWV0ZXLJMT476ACGyV9wyUTSfMpg6QHIQWdlIG9mIGXIP%2BUBOGFnZT86IGludDMyO%2BgBbENpdHnSKmNpdHk%2FOiBzdHLlAy7HLFByb2ZpbNNZQGVuY29kZSgiYmFzZTY0dXJsIuQBYHDGMD86IGJ5dGVzyUhUaGUgc3RhdHVzxEt0aGUgbGFzdCDkAMVhdGlvbuUDQSAgQHZpc2liaWxpdHkoTGlmZWN5Y2zkAeBhZMddxCDlA9BTdGF0xGflAavMFOkBSMRzzDLlAIDlAMph6QHVxXdAbHJvxDt1cwp1buQCctFU5QFk5gEa6QKyxF%2FIRyBjcmXEJ3JlcXVlc3QgaGFzIGJlZW4gYWNjZXB0ZWTEZyAgQccOOiAiyAsi1lBpxEDkALTpAMHIROwAnDogIswP2kx1cGRhdMRPxUNVxw46ICLIC8o76QTq6QDE5gDcZOcBolN1Y2NlZWTlAMXJDNM%2FxTbkAU1mYWlsyT5GxQ06ICLGCdw4d2FzIGNhbmNlyj5Dxw%2FkBULHC%2F8BQCBkZWxl6QGARMQN5gD5yAsi6QP96QN3bW926gHK6QN5TW92ZVLHFegDcsRzbW92xGhmcm9tIGxvY%2BYAvMVuxBPxA1DLM3RvzzF0b8ov9wCVc3BvbnPrBIvmAJbHFuwAl%2B4DbMU%2BxWTGfOYC7s1uaW50ZXJm5AZhT%2BgDlHMgZXh0ZW5kc%2FYHIy7LKXt9CuUG%2F8gjyhvLWegAzeYEs2dldOQBp0HKNeQD5%2BwFEOQEEHJl5Ab6ZEZyb23pBw4u9QXFICLmAqlPcuUC1WXlBI9AcmXkAPzqB0rVPMUqc2hhcmVkUm91dGXkBQ7NTE9sZO8ArEPHIFJlcGxhY2VBc3luY%2BwAvN9RxU71AVVMZWdhY3ku1WAKICAg6QFGLMUOT3DkAWZhbOcCm0JvZHkgPSB0cnXEdOUAiOUD%2FMZxcm1DdXN0b21QYXRjaFPXUvYAl0ZvdW7kBCvkAUPIHOYAy03kAonGSdBLyhDqBq%2FFGT7oAJ3mA5%2FvAVzlA5xlV2l0aG91dE9r8wFcbGlzdEJ5yDBHcm91cM9ETMUiUGFyZW501DxTdWJzY3Jp5QE%2BxzvGM8wZzDnoB2Ugc2FtcGzrBGthY8VEdGhhdOYDaOkHKHRvIGRpZmZl5ACE7wPrxSnuALJBxUjlAZbIdyzsBHbIDeYD7fMAkkhFQUTqB1HEfmNoZWNr6gCqZXhpc3RlbuYIyyDGHkXJFO8C4M0d7gim&e=%40azure-tools%2Ftypespec-autorest&vs=%7B%7D) showing how you would version a required to optional request body for a templated async put operation:
```
@armResourceOperations
interface Employees {
  get is ArmResourceRead<Employee>;

  @renamedFrom(Versions.`2025-10-07-preview`, "createOrUpdate")
  @removed(Versions.`2025-10-07-preview`)
  @sharedRoute
  createOrUpdateOld is ArmResourceCreateOrReplaceAsync<Employee>;
  @sharedRoute
  createOrUpdate is Azure.ResourceManager.Legacy.CreateOrReplaceAsync<
    Employee,
    OptionalRequestBody = true
  >;
  update is ArmCustomPatchSync<
    Employee,
    Azure.ResourceManager.Foundations.ResourceUpdateModel<
      Employee,
      EmployeeProperties
    >
  >;
  delete is ArmResourceDeleteWithoutOkAsync<Employee>;
  listByResourceGroup is ArmResourceListByParent<Employee>;
  listBySubscription is ArmListBySubscription<Employee>;

  /** A sample resource action that move employee to different location */
  move is ArmResourceActionSync<Employee, MoveRequest, MoveResponse>;

  /** A sample HEAD operation to check resource existence */
  checkExistence is ArmResourceCheckExistence<Employee>;
}
```
the trick is to use @sharedRoute in the old and new operations and to rename and remove the old operation in the new version.

# TypeSpec API Operations

## question 
Hi Team, 
Can I use Azure.Core.RpcOperation when defining the APIs in TypeSpec?

## answer
Is this a data plane API, or a management plane API?  For data plane APIs, this is appropriate if the APIs are not REST APIs.  If they are REST APIS, you should use the Resource-based API templates.
 
For management plane APIs, you should use the typespec-azure-resource-manager library.

# Hi team, could someone please help grant me permission to view the workflow for my Azure REST API PR?

## question 
Right now, after pushing my commit, I’m unable to see the error details for the validation checks, it just says “at least one review required to see the workflow.” This makes it difficult to verify if my changes are passing validation before the final review.
Would it be possible to enable workflow visibility for me so I can debug and ensure everything is in order ahead of time? PR link: [Stable version 2025-09-01 with prevalidation and autoscale changes by prachinandi · Pull Request #3…](https://github.com/Azure/azure-rest-api-specs/pull/37218)

## answer
You need to get the necessary permissions, see here: https://aka.ms/azsdk/access

# How to generate multiple inline allOfs (or equivalent)

## question 
We had this in our TypeSpec:
```
...
myProperty?: SharedDefinition1;
...
```
Which results in this swagger
```
"myProperty": {
    "$ref": "#/definitions/SharedDefinition1",
     ...
}
```
We are introducing a new API version and we want to update the property to look like this:
```
"myProperty": {
          "allOf": [
            {
              "$ref": "#/definitions/SharedDefinition1"

            },
            {
              "$ref": "#/definitions/SharedDefinition2"
            }
          ],
...
}
```
Both SharedDefinition1 and SharedDefinition2 are definitions that are shared by other properties, and so they cannot be updated. 
 
It seems like we cannot generate inline allOfs, so I was able to get this to work:
```
myProperty?: newDefinition; 
```
where newDefinition does a spread/includes all the properties of the two shared definitions. 
 
However this introduces versioning issues where our last preview version is now having it's $ref changed and I'm not sure how to avoid it... Would appreciate any help on that (or anything else if my approach is wrong!)
 
Thank you

Here is the actual PR for reference: [[DevCenter][Control Plane] Add 2025-10-01-preview for control plane by ArberH · Pull Request #37949…](https://github.com/Azure/azure-rest-api-specs/pull/37949/files#diff-27b2428ca26ef1210dfbf8197160af912685efb8c1f64f688cffeb46bba768b3)
 
Line 997 in models.tsp. 
myProperty = projectCatalogSettings, 
sharedDefinition1 = DevCenterProjectCatalogSettings
sharedDefinition2 = FeatureState
 
In the end I made projectCatalogSettings point to a new definition that contains all of the properties from DevCenterProjectCatalogSettings and FeatureState, however my issues is I don't know how to version this so it doesn't affect the old 2025-07-01-preview API version. 
 
The PR check that's failing is breaking change check and the VersioningReviewRequired label being applied since I'm modifying an already checked in swagger

## answer
InheritedProjectCatalogSettings should be marked as added in your new version
and you have to use @typeChangedFrom on projectCatalogSettings

# how do i use discriminated union

## question 
I'm wondering if I can model mutually exclusive properties and came across this thread recommending discriminated union, but I'm not able to make it work.
 
I want to have a model where only one property object can be specified. So only blobAccount xor onelakeAccount could be specified in this example:
```
model StorageDestination {
  blobAccount : BlobAccount;
  onelakeAccount: OneLakeAccount;
}
```

## answer
Generally, it is an anti-pattern to have a polymorphic resource type.  Instead of having one resource with two distinct rp-specific properties schemas, you generally should have two resources, or have a property of the rp-specific properties be polymorphic.
 
Discriminated unions are not yet handled by Azure emitters, so this isn't a good choice for Azure APIs.  You can use inheritance based discrimination instead.
 
Here's a sample using inheritance-based discrimination for a property of the rp-specific resource properties.
 
Note that you can use the 'kind' envelope property to make a resource polymorphic analogously, but this is, as I indicated, an anti-pattern.