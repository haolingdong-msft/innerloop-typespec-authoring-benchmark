# how to set readOnly for union

## question 
I have these lintDiff [errors](https://github.com/Azure/azure-rest-api-specs/actions/runs/16303501902): 
```
| ProvisioningStateMustBeReadOnly | provisioningState property must be set to readOnly. Location: GalleryRP/stable/2025-03-03/GalleryRP.json#L3483 | RPC-Async-V1-16 |
| ProvisioningStateMustBeReadOnly | provisioningState property must be set to readOnly. Location: GalleryRP/stable/2025-03-03/GalleryRP.json#L3545 | RPC-Async-V1-16 |
| ProvisioningStateMustBeReadOnly | provisioningState property must be set to readOnly. Location: GalleryRP/stable/2025-03-03/GalleryRP.json#L3551 | RPC-Async-V1-16 |
```
Pretty much I have set union [GalleryProvisioningState](https://github.com/Azure/azure-rest-api-specs/blob/2acbb85d39640fc0b45a053023d79bc16ecc0a7d/specification/compute/Gallery.Management/models.tsp#L19) to readOnly
I tried adding `use-read-only-status-schema: true` to tspconfig.yaml but it changed some other unions and adding breaking changes 
 
is there another way to resolve this ? 

## answer
use-read-only-status-schema will change the status schema of any unions that are effectively read-only (that is, all the properties that use the union are marked as readOnly).  So, unless you are thinking that a user can actually set the value for any of the changed unions,  that is the recommendation.
 
`readOnly` requirements in lintdiff are bit over-used,  there is no difference between a response-only property that is marked as 'readOnly'  and a response-only property that is unmarked.  

# Guidelines to Implement Custom Patch

## question 
Hi Team! We are planning to implement a custom model for patch. Are there any guidelines available for this? I found some information about "TrackedResourceUpdate," but it doesn't seem to be included in the package anymore.
If you have any examples, especially on implementing the model for Properties and referencing it for patch calls, that would be very helpful.

## answer
You want to make sure to represent the properties that can be PATCHed in the patch operation, generally this includes any properties that are not generated on the service (e.g. type, id, name, systemData) or settable only on creation (e.g. location), and make sure these properties are optional and have no defaults.
 
You can do this either be creating a separate model type for patch, or by using standard transformations to filter out the readOnly and createOnly properties and make these optional

- [Here is a sample of using a fully bespoke patch model](https://azure.github.io/typespec-azure/playground/?options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D&c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCn3mAPNB6AD16wEOIOgCMOQAyG1vZGVsIEVtcGxveWVlIGlzIFRyYWNrZWToAII8yBxQcm9wZXJ0aWVzPuUBJC4u6QCm5AHWUGFyYW1ldGVyyTE%2BO%2BgAhlRoZSBQQVRDSCDGb2Zvcspz8QCFVXBkYXRlyGT2ARBGb3VuZGF05QEHQXJtVGFnc%2BcAoHk7CucBwXJwLeQDJWlmaWMgcMYdaWXlAfEgyxA%2FOsl5x0JpZXPmAIP0AMBkb%2BcAwMxeZcdBz2fuANfQXukCaUFnZSBvZspF5QChYWdlPzogaW50MzLpANFDaXR50ipjaXR5Pzogc3Ry5QPPxyxQcm9maWzTWUBlbmNvZGUoImJhc2U2NHVybCLkAkZwxjA%2FOiBieXRlc%2BkA%2B%2BkBp%2F8A28gc%2FwDV%2FwDV%2FwDV%2FwDV%2FwDVc8lI5AHQc3RhdHVzxEt0aGUgbGFzdCDkAMXlAlTlBLcgIEB2aXNpYmlsaXR5KExpZmVjeWNs5AKLYWTHXcQg5QVGU3RhdMRn5QNmzBTtAkPMMuUAgOUAymHpA5DFd0Bscm%2FEO3VzCnVu5ARt0VTlAWTmARos7ADSyEcgY3JlxCdyZXF1ZXN0IGhhcyBiZWVuIGFjY2VwdGVkxGcgIEHHDjogIsgLItZQacRA5AC06QDByETsAJw6ICLMD9pMdeQC%2F8RPxUPlAw3GP8gLyjvpBmDpAMTmANxk5wGiU3VjY2VlZOUAxckM0z%2FFNuQBTWZhaWzJPkbFDTogIsYJ3Dh3YXMgY2FuY2XKPkPHD%2BQGuMcL%2FwFAIGRlbGXpAYBExA3mAPnICyLpBbjpA3dtb3bqAcrpA3lNb3ZlUscV6ANyxHNtb3bEaGZyb20gbG9j5gC8xW7EE%2FEDUMszdG%2FPMXRvyi%2F3AJVzcG9uc%2BsFweYAlscW7ACX7gNsxT7FZMZ85gLuzW5pbnRlcmbkB9dP6AOUcyBleHRlbmRz9giZLsspe30K5Qh1yCPKG8tZ6ADN5gSzZ2V05AGnQco15APn7AbLIOcCe09y5wW%2Fzi9Dxx1SZXBsYWNlQXN5bmPOP%2BUC98g3Q3VzdG9tUGF0Y2hTzCos7wcGxTrmAjfPceUCNGVXaXRob3V0T2vTcWxpc3RCecgwR3JvdXDPREzFIlBhcmVudNQ8U3Vic2NyaXDlAhbGO8YzzBnMOegF%2FSBzYW1wbOsDA2FjxUR0aGF05gIA6QXAdG8gZGlmZmXkAITvAoPFKe4AskHFSO8BM%2BsDDsgN5gKF8wCSSEVBROoF6cR%2BY2hlY2vqAKpleGlzdGVu5gkeIMYeRckU7wH1zR3uCPk%3D&e=%40azure-tools%2Ftypespec-autorest&vs=%7B%7D)
```
/** A ContosoProviderHub resource */
model Employee is TrackedResource<EmployeeProperties> {
  ...ResourceNameParameter<Employee>;
}

/** The PATCH model for Employee */
model EmployeeUpdate {
  ...Azure.ResourceManager.Foundations.ArmTagsProperty;

  /** rp-specific properties */
  properties?: EmployeePropertiesUpdate;
}

/** The PATCH mdoel for rp-specific employee properties */
model EmployeePropertiesUpdate {
  /** Age of employee */
  age?: int32;

  /** City of employee */
  city?: string;

  /** Profile of employee */
  @encode("base64url")
  profile?: bytes;
}

/** Employee properties */
model EmployeeProperties {
  /** Age of employee */
  age?: int32;

  /** City of employee */
  city?: string;

  /** Profile of employee */
  @encode("base64url")
  profile?: bytes;

  /** The status of the last operation. */
  @visibility(Lifecycle.Read)
  provisioningState?: ProvisioningState;
}

/** The provisioning state of a resource. */
@lroStatus
union ProvisioningState {
  string,

  /** The resource create request has been accepted */
  Accepted: "Accepted",

  /** The resource is being provisioned */
  Provisioning: "Provisioning",

  /** The resource is updating */
  Updating: "Updating",

  /** Resource has been created. */
  Succeeded: "Succeeded",

  /** Resource creation failed. */
  Failed: "Failed",

  /** Resource creation was canceled. */
  Canceled: "Canceled",

  /** The resource is being deleted */
  Deleting: "Deleting",
}

/** Employee move request */
model MoveRequest {
  /** The moving from location */
  from: string;

  /** The moving to location */
  to: string;
}

/** Employee move response */
model MoveResponse {
  /** The status of the move */
  movingStatus: string;
}

interface Operations extends Azure.ResourceManager.Operations {}

@armResourceOperations
interface Employees {
  get is ArmResourceRead<Employee>;
  createOrUpdate is ArmResourceCreateOrReplaceAsync<Employee>;
  update is ArmCustomPatchSync<Employee, EmployeeUpdate>;
  delete is ArmResourceDeleteWithoutOkAsync<Employee>;
  listByResourceGroup is ArmResourceListByParent<Employee>;
  listBySubscription is ArmListBySubscription<Employee>;

  /** A sample resource action that move employee to different location */
  move is ArmResourceActionSync<Employee, MoveRequest, MoveResponse>;

  /** A sample HEAD operation to check resource existence */
  checkExistence is ArmResourceCheckExistence<Employee>;
}
```
- [Here is a sample of using transformations](https://azure.github.io/typespec-azure/playground/?options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D&c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCn3mAPNB6AD16wEOIOgCMOQAyG1vZGVsIEVtcGxveWVlIGlzIFRyYWNrZWToAII8yBxQcm9wZXJ0aWVzPuUBJC4u6QCm5AHWUGFyYW1ldGVyyTE%2BO%2BQAhmFsaWFzIFBhdGNoTcRsPAogIFQgZXh0ZW5kcyB7fSwKICBPbWl0dGVkymLJIHN0cuQCjD0gIiLEKcRpVGVtcGxhdGXJJHZhbHVlb2bLLHvkAhd9VXBkYXRlIgo%2BID0gxgxhYmzrAMc8T3B0aW9uYWzME21pdERlZmF1bHTGDcsc5AC59QCuCj4%2BPj47Cu8BTMogxn3kAVzrAQfSJ8RD5AG0VGhlIFBBVENIIMZRZm9yIOQA9MQu5QKwzmjGXgog12As8wFePSAi5AEiIiB8ICJwyRci5gHY5ACDcnAt5ARgaWZpYyBwxFTkATogyivmAwLKED86%2BQD35QIFxFTIIc9H%2BAE16QCMQWdlIG9m6QECxnthZ2U%2FOiBpbnQzMjsKxylDaXR50ipjaXR5PzrnAh3JLFByb2ZpbNNZQGVuY29kZSgiYmFzZTY0dXJsIuQDZXDGMD86IGJ5dGVzyUjkAaxzdGF0dXPES3RoZSBsYXN0IOQAxWHkAl3lBQEgIEB2aXNpYmlsaXR5KExpZmVjeWNs5APlYWTHXcQg5QWQU3RhdMRn5QOwzBTpAUjEc8wy5QCA5QDKYekD2sV3QGxyb8Q7dXMKdW7kBLfRVOUBZOYBGizsANLIRyBjcmXEJ3JlcXVlc3QgaGFzIGJlZW4gYWNjZXB0ZWTEZyAgQccOOiAiyAsi1lBpxEDkALTpAMHIROwAnDogIswP2kx15AJixE%2FFQ%2BUCcMY%2FyAvKO%2BkGqukAxOYA3GTnAaJTdWNjZWVk5QDFyQzTP8U25AFNZmFpbMk%2BRsUNOiAixgncOHdhcyBjYW5jZco%2BQ8cP5AcCxwv%2FAUAgZGVsZekBgETEDeYA%2BcgLIukGAukDd21vduoByukDeU1vdmVSxxXoA3LEc21vdsRoZnJvbSBsb2PmALzFbsQT8QNQyzN0b88xdG%2FKL%2FcAlXNwb25z6waQ5gCWxxbsAJfuA2zFPsVkxnzmAu7NbmludGVyZuQIIU%2FoA5TqBl72B2zLKXt9CuUIv8gjyhvLWegAzeYEs2dldOQBp0HKNeQD5%2BwHFSDnAntPcuoGGcsvQ8cdUmVwbGFjZUFzeW5jzj%2FlAvfIN0N1c3RvbeUF%2BVPMKizvBiHFOuYCN89x5QI0ZVdpdGhvdXRPa9NxbGlzdEJ5yDBHcm91cM9ETMUiUGFyZW501DxTdWJzY3Jp5QdxxzvGM8wZzDnoBf0gc2FtcGzrAwNhY8VEdGhhdOYCAOkFwHRvIGRpZmZl5ACE7wKDxSnuALJBxUjvATPrAw7IDeYChfMAkkhFQUTqBenEfmNoZWNr6gCqZXhpc3RlbuYJaCDGHkXJFO8B9c0d7glD&e=%40azure-tools%2Ftypespec-autorest&vs=%7B%7D)
```
/** A ContosoProviderHub resource */
model Employee is TrackedResource<EmployeeProperties> {
  ...ResourceNameParameter<Employee>;
}

alias PatchModel<
  T extends {},
  OmittedProperties extends string = "",
  NameTemplate extends valueof string = "{name}Update"
> = UpdateableProperties<OptionalProperties<OmitDefaults<OmitProperties<
  T,
  OmittedProperties
>>>>;

model EmployeePropertiesUpdate is PatchModel<EmployeeProperties>;

/** The PATCH model for employees */
model EmployeeUpdate
  is PatchModel<Employee, OmittedProperties = "name" | "properties"> {
  /** rp-specific patchable properties */
  properties?: EmployeePropertiesUpdate;
}

/** Employee properties */
model EmployeeProperties {
  /** Age of employee */
  age?: int32;

  /** City of employee */
  city?: string;

  /** Profile of employee */
  @encode("base64url")
  profile?: bytes;

  /** The status of the last operation. */
  @visibility(Lifecycle.Read)
  provisioningState?: ProvisioningState;
}

/** The provisioning state of a resource. */
@lroStatus
union ProvisioningState {
  string,

  /** The resource create request has been accepted */
  Accepted: "Accepted",

  /** The resource is being provisioned */
  Provisioning: "Provisioning",

  /** The resource is updating */
  Updating: "Updating",

  /** Resource has been created. */
  Succeeded: "Succeeded",

  /** Resource creation failed. */
  Failed: "Failed",

  /** Resource creation was canceled. */
  Canceled: "Canceled",

  /** The resource is being deleted */
  Deleting: "Deleting",
}

/** Employee move request */
model MoveRequest {
  /** The moving from location */
  from: string;

  /** The moving to location */
  to: string;
}

/** Employee move response */
model MoveResponse {
  /** The status of the move */
  movingStatus: string;
}

interface Operations extends Azure.ResourceManager.Operations {}

@armResourceOperations
interface Employees {
  get is ArmResourceRead<Employee>;
  createOrUpdate is ArmResourceCreateOrReplaceAsync<Employee>;
  update is ArmCustomPatchSync<Employee, EmployeeUpdate>;
  delete is ArmResourceDeleteWithoutOkAsync<Employee>;
  listByResourceGroup is ArmResourceListByParent<Employee>;
  listBySubscription is ArmListBySubscription<Employee>;

  /** A sample resource action that move employee to different location */
  move is ArmResourceActionSync<Employee, MoveRequest, MoveResponse>;

  /** A sample HEAD operation to check resource existence */
  checkExistence is ArmResourceCheckExistence<Employee>;
}
```
The advantage to using transformations is that, as the model versions, the PATCH model will also version automatically, whereas if you use a completely bespoke patch model, you will need to remember to make appropriate versioning changes there as well as in the resource model.

# Location based extension resource off a tenant level resource

## question 
Hi
 
My understanding is that extension resource will always follow the location of the parent resource. Since tenant resource (service group) wont have a location, extension resource will also need to be a global resource.
Is there any way to create a location based extension resource off a tenant level resource?

## answer
extension resources can apply globally, to subscriptions, resource groups, management groups, or individual resources, but since there is no global concept of location, the ways it might apply to a specific location might be:
- Apply to a location-based resource (`/subscriptions/{subscriptionId}/providers/Microsoft.TargetRPNamespace/locations/{location}/targetResources/{targetResourceName}/providers/Microsoft.ExtensionNamespace/extensionResources/{extensionResourceName}`)
- Apply to your RP's locations:
(`/subscriptions/{subscriptionId}/providers/Microsoft.ExtensionNamespace/locations/{location}/extensionResources/{extensionResourceName}`)
However, you should talk with the ARM team about your resource to verify what the best options are.

# "is referencing versioned type but is not versioned"

## question 
```
'Microsoft.Compute.{ statusCode: 202, location: string, retryAfter: int32, _: Microsoft.Compute.GalleryScriptVersion }._' is referencing versioned type 'Microsoft.Compute.GalleryScriptVersion' but is not versioned itself. TypeSpec(@typespec/versioning/incompatible-versioned-reference)
```
how do I resolve it? 
at the beginning of the file, it is defining GalleryScriptVersion which has added decorator. 
 
Where do I need to add 'added' decorator here? 
```
/**
 * Create or update a gallery Script Version. Script versions help save different states.
 */
#suppress "@azure-tools/typespec-azure-resource-manager/arm-put-operation-response-code"
#suppress "@azure-tools/typespec-azure-resource-manager/no-response-body" "For backward
@added(Versions.v2025_03_03)
createOrUpdate is ComputeResourceCreateOrReplaceAsync<
    GalleryScriptVersion,
    Response = ArmResourceUpdatedResponse<GalleryScriptVersion> | ArmResourceCreatedRespo
        GalleryScriptVersion,
        ArmLroLocationHeader & Azure.Core.Foundations.RetryAfterHeader
    > (ArmAcceptedLroResponse & {
    @bodyRoot
    _: GalleryScriptVersion;
    })
>;
```

## answer
was able to resolve it this way.
```
/**
 * Create or update a gallery Script Version. Script versions help save different states.
 */
#suppress "@azure-tools/typespec-azure-resource-manager/arm-put-operation-response-code"
#suppress "@azure-tools/typespec-azure-resource-manager/no-response-body" "For backward
@added(Versions.v2025_03_03)
createOrUpdate is ComputeResourceCreateOrReplaceAsync<
    GalleryScriptVersion,
    Response = ArmResourceUpdatedResponse<GalleryScriptVersion> | ArmResourceCreatedRespo
        GalleryScriptVersion,
        ArmLroLocationHeader & Azure.Core.Foundations.RetryAfterHeader
    > (ArmAcceptedLroResponse & {
    @bodyRoot
    @added(Versions.v2025_03_03)
    _: GalleryScriptVersion;
    })
>;
```

# Resource Provider Implementation - Generating Models from typespec

## question 
We are a new resource provider implementation utilising RPaaS. We are using typespec to generate our open-api specs.
 
When starting our project we decided not to use typespec-providerhub-controller to generate controller code as it was no longer under active development, with plans for new service emitters at the time https://stackoverflow.microsoft.com/a/451677/180368
Is the service code emitter now available?
We are now formalising our typespec model and looking to utilise any code generation tools for C#/.NET that could keep our API models (but not necessarily controller - we are happy to write those) aligned with the api spec definitions
What is the recommended pattern to generate models for C#/.NET? What patterns have teams had success with and are there any pitfalls to note?
Is there an example repository and pattern we should emulate

## answer
Right now there is no recommendation for RPaaS extensions - typespec-providerhub-controller is still supported.

# having trouble with examples not matching @pattern rules in github actions

## question 
I think I'm doing something wrong when I generate my examples... what should i be doing?
 
for example this tsp:
```
model AcStorConfiguration is ExtensionResource<AcStorConfigurationProperties> {
  ...ResourceNameParameter<
    AcStorConfiguration,
    NamePattern = "^acstor-configuration$"
  >;
}
```
then:
```
oav generate-examples ./specification/arccontainerstorage/resource-manager/Microsoft.ArcContainerStorage/preview/2024-10-01-preview/arccontainerstorage.json
```
and i run 
```
npx prettier --write specification/arccontainerstorage/resource-manager/Microsoft.ArcContainerStorage/preview/2024-10-01-preview/examples/*  
 npx tsv specification/arccontainerstorage/ArcContainerStorage.Management    
```
example github action failure:https://github.com/Azure/azure-rest-api-specs-pr/pull/23604/checks?check_run_id=46129519720

## answer
I think you need to manually update the auto-generated strings to satisfy the regexes. 
 
most of the errors, the example itself tells you to update the string:
 
```
GitHub Actions / [TEST-IGNORE] Swagger ModelValidation

PATTERN: String does not match pattern ^acstor-configuration$: Replace this value with a string matching RegExp ^acstor-configuration$
```
This one is a little unusual, but I think just update the string to something that works, unless your spec is doing something unusual with this id property.
```
GitHub Actions / [TEST-IGNORE] Swagger ModelValidation

INVALID_FORMAT: Object didn't pass validation for format arm-id: gkbwmag
```
Examples generation was written to produce a structure that you can update, but there is more work necessary to fully generate the placholders. It's just not been prioritized work unfortunately.