# ArmResourcePatchAsync & discriminator

## question 
I was trying to figure out the best way to allow an update for a Host resource. I tried ArmResourcePatchAsync, but the resource has a discriminator. oav fails with OBJECT_MISSING_REQUIRED_PROPERTY_DEFINITION .  [Windows Server AHB for VMware via PATCH by cataggar · Pull Request #25538 · Azure/azure-rest-api-sp…](https://github.com/Azure/azure-rest-api-specs-pr/pull/25538)

## answer
we generally suggest that PATCH requests over discriminated types should require the discriminator property.  This may result in some lintdiff violations, but that is expected, and those cna be suppressed.  This is especially true if, as most services, your PATCH operation would need the discriminator value on the wire to determine how to apply the PATCH request to the existing reosurce.

# ARM Async operation with custom operation

## question 
Hello, I have a custom operation defined as :

```
  #suppress "@azure-tools/typespec-azure-core/casing-style" "The field name `name` is the valid field name."
  @doc("Deletes the LaunchBulkInstancesOperations.")
  @delete
  @armResourceDelete(LaunchBulkInstancesOperation)
  delete(
    ...CustomParams,
  ): ArmDeletedResponse | ArmDeletedNoContentResponse | ErrorResponse;
```
Which is currently modelled as a sync operation, how would I go about making this an ARM async operation? It is currently custom modelled so we can have the endpoint look like below, so using ArmResourceDeleteWithoutOkAsync would not fit this use case directly, unless we can reorder/customize the params
```
/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ComputeBulkActions/locations/{location}/launchBulkInstancesOperations/{name}/cancel
```

## answer
The standard  operation templates require CRUD operations to use the resource Id, because they are meant to model conformance to the ARM RPC.  For operations outside the RPC, you should use legacy templates.  For an operation like this one, I think the simplest thing is to use the routed operation templates [as in this sample](https://azure.github.io/typespec-azure/playground/?options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D&c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIOQA10NvbW1vblTkAY%2FHQCj1ATcuyykuyGoudjUpCiAgYNJpYCwKfQoKbW9kZWwgTGF1bmNoQnVsa0luc3RhbmNlT3BlcmF0xEIKICBpc%2BQBfHh5yHE80jBQcm9wZXJ0aWVzPuUA3S4u6QCf5AGPUGFyYW1ldGVy0zvKaywgS2V5xC8gPSAi5AF2Ij475ACl5AEqcnAt5AKOaWZpYyBwyW3kASb4AMPqAJPpAW%2FTRXnEQyDFDjE6IHN0cuUCsOYAwkRlZmF1bHTlAeXnAstTdGF0yFp55QCdYWxpYXPTf3NPcHMgPfYC4i5MZWdhY3kuUm91dGVk6gEBPAogIFBhcmVudOkBMcRE5AC%2F5QCRQXBp5wHZySA7yBxTdWJzY3JpcMRJSWTSIOgAg0dyb3Vw0h9Mb2PlAITNGn0sCiDpA4DkAlnJHiA9yRjuAeDFUP0B5cUi8AHpCiAgPsxt5QEaID0gI%2BYA%2FHLEDzogIi9z6wDmcy97zA9JZH3kBRvqAOVzL3vNEMRxfS9w5wOzcy%2FsA85tcHV0ZeQAsUFjxlts5wEQcy97yAt9L2z0AeboANkve%2BQAyn0vY8QYbCLkAM7mAUDlAeXsAS7kAPb8ASMiCj47CgppbnRlcmbkBHfKGiBleHRlbmRz9wJXyyl7fQrlBRXII8ob5AUNYWxsb3fkAsxpY%2BUAn3M6IHRydWXkBQPKd%2FUC1MphCiAgZGVsZXRl5AQg1SxzLkTFIVdpdGhvdXRPa0FzeW5j%2FQQD5QPx&e=%40azure-tools%2Ftypespec-autorest&vs=%7B%7D):
```
import "@typespec/http";
import "@typespec/rest";
import "@typespec/versioning";
import "@azure-tools/typespec-azure-core";
import "@azure-tools/typespec-azure-resource-manager";

using Http;
using Rest;
using Versioning;
using Azure.Core;
using Azure.ResourceManager;

/** Contoso Resource Provider management API. */
@armProviderNamespace
@service(#{ title: "ContosoProviderHubClient" })
@versioned(Versions)
namespace Microsoft.ContosoProviderHub;

/** Contoso API versions */
enum Versions {
  /** 2021-10-01-preview version */
  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)
  `2021-10-01-preview`,
}

model LaunchBulkInstanceOperations
  is ProxyResource<LaunchBulkInstanceProperties> {
  ...ResourceNameParameter<LaunchBulkInstanceOperations, KeyName = "name">;
}

/** rp-specific properties */
model LaunchBulkInstanceProperties {
  /** rp-specific property */
  prop1: string;

  ...DefaultProvisioningStateProperty;
}

alias LaunchBulkInstancesOps = Azure.ResourceManager.Legacy.RoutedOperations<
  ParentParameters = {
    ...ApiVersionParameter;
    ...SubscriptionIdParameter;
    ...ResourceGroupParameter;
    ...LocationParameter;
  },
  ResourceTypeParameter = ResourceNameParameter<
    LaunchBulkInstanceOperations,
    KeyName = "name"
  >,
  ResourceRoute = #{
    route: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ComputeBulkActions/locations/{location}/launchBulkInstancesOperations/{name}/cancel",
  },
  RoutedResourceName = "LaunchBulkInstanceOperations"
>;

interface Operations extends Azure.ResourceManager.Operations {}

@armResourceOperations(#{ allowStaticRoutes: true })
interface LaunchBulkInstancesOperations {
  delete is LaunchBulkInstancesOps.DeleteWithoutOkAsync<LaunchBulkInstanceOperations>;
}
```

# Use open API x-ms-client-flatten: true in model

## question 
I have existing models that use x-ms-client-flatten: true.
 
What is the way to achieve this in Typespec

## answer
for back compatibility only you can use this decorator and add reason in suppression
```
@Azure.ClientGenerator.Core.Legacy.flattenProperty
```
ignore the emitter option it shouldn't be used and will be removed next release

# Allow property update only through PUT and not Patch

## question 
Hi Team,
 
Our resource properties contain some optional fields that can be created with some value and later updated to null if customer wants and we support both PUT and PATCH calls the the resource. However RPaaS behavior will not allow to remove an existing field from resource through Patch ([rpaas - How to can customers and user RP remove properties during PATCH with - Stack Overflow at Mi…](https://stackoverflow.microsoft.com/questions/442814/442831#442831)), it looks inconsistent if a customer tries to patch it to null. With UpdateProperties auto generated from TSP, is there any suggestion how to not allow these be updated through Patch. We will set the expectation that it has to be updated through a PUT call.

## answer
Here are you talking about the envelope properties, or the rt-specific property bag of your resource?  ARM RPC strongly suggests that Json MergePatch semantics are followed for the rt-specific proeprty bag, and seems that RPaaS needs to support this.

For envelope properties, which generally come from common types, there is an effort to specify PATCH behavior for common-types that would include envelope properties, but this is unlikely to be concluded until the new year..
 
There is no really good way to specify properties that are unerasable in PATCH, although there is a proposal to use defaults to allow this ( default value would be the value the property is set to when a 'null' is sent on the wire).
 
For now, the best advice is to ensure that patch request properties are optional and (for now) have no defaults.  It is inadvisable to exclude properties settable by the user from PATCH requests.

# Playground usage

## question 
Hi, 
Question on usage of the playground at https://azure.github.io/typespec-azure/playground . When we are putting together something to use as an example for a new addition of a child proxy resource to our spec we get import errors. This is because we are importing from a common model files. 
 
Is it possible to add files or somehow scope a playground so its context is our existing specification so it imports the references correctly.  For example our spec is in \specification\netapp\resource-manager\Microsoft.NetApp\NetApp that includes models.tsp file. 
Can we create a playground that would resolve something like import "./../models.tsp";  

## answer
There is no a 'remote import' feature in the typespec azure playground.

# Moving from ArmCustomPatchSync to ArmResourcePatchSync for PATCH operations

## question 
In earlier versions of our resource-types, we had couple of properties which were not allowed for PATCH hence we started with ArmCustomPatchSync with different PATCH model.
 
I.e.
update is ArmCustomPatchSync<Site, SiteUpdate>;
 
However, in last api-version, we made some changes in resource properties where PUT and PATCH models are exactly same. 
 
With this change, what is the recommendation now? Should we remove custom PatchModel (i.e. SiteUpdate) and move to ArmResourcePatchSync operation instead?
 
I tried changing as described above, the changes got flagged as breaking change.
https://github.com/Azure/azure-rest-api-specs-pr/pull/25577

## answer
Because you want to maintain the names of PATCH request types and because ArmResourcePatch performs automatic transformations over the resource, it is suggested that you continue to use ArmCustomPatch and update the proeprties to conform with changes in the resource model.
There are some tools that can help you with this (There are core transformation templates UpdateableProperties, OptionalProperties, OmitDefaults, and OmitProperties that you can use, like this)

And a recursive MergePatch transform is coming in a future release.
