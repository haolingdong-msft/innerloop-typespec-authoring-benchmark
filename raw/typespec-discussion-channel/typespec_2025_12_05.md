# Problems Introducing Versioned Name Pattern

## question 
Hello team, 
 
I am trying to introduce versioned name pattern to satisfy some swaggerLint check errors and finding a bit of difficulty in achieving this. I have tried quite a few methods, such as defining two model types with previous not including pattern and new versions including patterns, directly injecting the name patterns to new versions, and also simply using the @added @RenamedFrom @removed combination in the same model, but each is greeted with tsp compile or format errors. Here is what Im working with currently:
```
@added(Versions.v2024_03_03)
@removed(Versions.v2025_03_03)
model OldGalleryNameKey {
  @visibility(Lifecycle.Read)
  @path
  @segment("galleries")
  @Azure.ResourceManager.Private.defaultResourceKeySegmentName(
    Gallery,
    "galleryName",
    "galleries"
  )
  oldGalleryName: string;
}

/**
* Specifies information about the Shared Image Gallery that you want to create or update.
*/
model Gallery is Azure.ResourceManager.TrackedResource<GalleryProperties> {
  ...OldGalleryNameKey;

  @added(Versions.v2025_03_03)
  @renamedFrom(Versions.v2025_03_03, "oldGalleryName")
  @pattern("^[a-zA-Z0-9]([a-zA-Z0-9._-]*[a-zA-Z0-9])?$")
  @visibility(Lifecycle.Read)
  @path
  @segment("galleries")
  @Azure.ResourceManager.Private.defaultResourceKeySegmentName(
    Gallery,
    "galleryName",
    "galleries"
  )
  name: string;

  /**
   * The identity of the gallery, if configured.
   */
  #suppress "@azure-tools/typespec-azure-resource-manager/arm-resource-invalid-envelope-property" "For backward compatibility"
  identity?: GalleryIdentity;
}
```
And this is giving a "more than one key found on model type Gallery" error, any pointers greatly appreciated!

## answer
It's possible to version this, but you would need to version the resource and all its operations.   Because constraints usually don't change for only a single api-version, but for all versions in the service (remember that you are usually required to be able to access resources created by any api-version in any other api-version), and because clients don't actually use constraints, it is usually better and more accurate to just make the constraint change for all versions.
Here is an [example](https://azure.github.io/typespec-azure/playground/?options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D&c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIOQA10NvbW1vblTkAY%2FHQCj1ATcuyykuyGoudjUpCiAgYNJpYCwK%2FwCF%2FwCF%2FwCF9gCFNc5pYCwKfeYBOEHoATrrAVMg6AJ15QHicmXkAYlkRnJvbekBnS7VVCAiRW1wbG95ZWUiKcQ4bW926wHR1TQpCm1vZGVsIMg5T2xkIGlzIFRyYWNrZWToAOU8yB9Qcm9wZXJ0aWVzPuUBzC4u6QEJ5AJ%2BUGFyYW1ldGVyyTEsIMYYdHRlcm4gPSAiXlthLXpBLVowLTldKyQiPjvkAQlAYWRk%2FwCq8QCq%2FwCn%2FwCn7wCn5gCH5AGQyV9wyUTkAYbOfMpg6QLSQWdlIG9mIGXIP%2BUCQmFnZT86IGludDMyO%2BgCdkNpdHnSKmNpdHk%2FOiBzdHLlBDjHLFByb2ZpbNNZQGVuY29kZSgiYmFzZTY0dXJsIuQCanDGMD86IGJ5dGVzyUhUaGUgc3RhdHVzxEt0aGUgbGFzdCDkAMVhdGlvbuUESyAgQHZpc2liaWxpdHkoTGlmZWN5Y2zkAuphZMddxCDlBNpTdGF0xGflArXMFOkBSMRzzDLlAIDlAMph6QLfxXdAbHJvxDt1cwp1buQDfNFU5QFk5gEa6QO8xF%2FIRyBjcmXEJ3JlcXVlc3QgaGFzIGJlZW4gYWNjZXB0ZWTEZyAgQccOOiAiyAsi1lBpxEDkALTpAMHIROwAnDogIswP2kx1cGRhdMRPxUNVxw46ICLIC8o76QX06QDE5gDcZOcBolN1Y2NlZWTlAMXJDNM%2FxTbkAU1mYWlsyT5GxQ06ICLGCdw4d2FzIGNhbmNlyj5Dxw%2FkBkzHC%2F8BQCBkZWxl6QGARMQN5gD5yAsi6QUH6QN35AS06QHK6QN5TW92ZVLHFegDcsRzbW92xGhmcm9tIGxvY%2BYAvMVuxBPxA1DLM3RvzzF0b8ov9wCVc3BvbnPlA4LsAJbHFuwAl%2B4DbMU%2BxWTGfOYC7s1uaW50ZXJm5AdrT%2BgDlHMgZXh0ZW5kc%2FYILS7LKXv%2FBUPqBUPkBtPIScpBy3%2FoAPPmBNlAc2hhcmVkUm91dGUKICBnZXTkAdxBykTkBBzsBUXRM%2BYCv09y5QLr5QIayz5Dxx1SZXBsYWNlQXN5bmPdTuUDSshGQ3VzdG9tUGF0Y2hTxDkKICAg6QDALMUO9gE6Rm91buQDeeQBJ8gc5gCgTeQB18ZJ0EvKEOoF%2FcUZPgogIPQArOYC%2FO8A8uUC%2BWVXaXRob3V0T2v%2FAPIKICBsaXN0QnnIP0dyb3Vwz1NMxSJQYXJlbnTfS8QpU3Vic2NyaXDlAvnGSsZCzBnMSOgG4CBzYW1wbOsD5mFjxUR0aGF05gLj6QajdG8gZGlmZmXkAJPvA2bvAJTFOO4A0EHFV%2BUB0uoIResEAMgN5gN38wChSEVBROoG2%2BQAjWNoZWNr6gC5ZXhpc3RlbuYJX%2FICssQtRckj7wKyzR3vCD%2F%2FCar2Capz%2Fwmr%2FwO%2B9wO%2B5AnH%2FwPB8wPBT2xk%2FwPE%2FwPE8APE11H%2FA8frA2xPbGT%2FA8r%2FA8rtA7rJTv8Dzf8Dzf8Dzf0A%2B%2F8D0PgD0N1O%2FwPT7wPTxkv%2FA9b%2FA9b%2FA9b%2FA9brAY79A9n%2FA9j%2FA9j%2FA9j%2FA9jsASx9Cg%3D%3D&e=%40azure-tools%2Ftypespec-autorest&vs=%7B%7D).  
```
/** A ContosoProviderHub resource */
@renamedFrom(Versions.`2025-10-01-preview`, "Employee")
@removed(Versions.`2025-10-01-preview`)
model EmployeeOld is TrackedResource<EmployeeProperties> {
  ...ResourceNameParameter<Employee, NamePattern = "^[a-zA-Z0-9]+$">;
}

@added(Versions.`2025-10-01-preview`)
model Employee is TrackedResource<EmployeeProperties> {
  ...ResourceNameParameter<Employee>;
}

@added(Versions.`2025-10-01-preview`)
@armResourceOperations
interface Employees {
  @sharedRoute
  get is ArmResourceRead<Employee>;
  @sharedRoute
  createOrUpdate is ArmResourceCreateOrReplaceAsync<Employee>;
  @sharedRoute
  update is ArmCustomPatchSync<
    Employee,
    Azure.ResourceManager.Foundations.ResourceUpdateModel<
      Employee,
      EmployeeProperties
    >
  >;
  @sharedRoute
  delete is ArmResourceDeleteWithoutOkAsync<Employee>;
  @sharedRoute
  listByResourceGroup is ArmResourceListByParent<Employee>;
  @sharedRoute
  listBySubscription is ArmListBySubscription<Employee>;

  /** A sample resource action that move employee to different location */
  @sharedRoute
  move is ArmResourceActionSync<Employee, MoveRequest, MoveResponse>;

  /** A sample HEAD operation to check resource existence */
  @sharedRoute
  checkExistence is ArmResourceCheckExistence<Employee>;
}

@renamedFrom(Versions.`2025-10-01-preview`, "Employees")
@removed(Versions.`2025-10-01-preview`)
@armResourceOperations
interface EmployeesOld {
  @sharedRoute
  get is ArmResourceRead<EmployeeOld>;
  @sharedRoute
  createOrUpdate is ArmResourceCreateOrReplaceAsync<EmployeeOld>;
  @sharedRoute
  update is ArmCustomPatchSync<
    EmployeeOld,
    Azure.ResourceManager.Foundations.ResourceUpdateModel<
      EmployeeOld,
      EmployeeProperties
    >
  >;
  @sharedRoute
  delete is ArmResourceDeleteWithoutOkAsync<EmployeeOld>;
  @sharedRoute
  listByResourceGroup is ArmResourceListByParent<EmployeeOld>;
  @sharedRoute
  listBySubscription is ArmListBySubscription<EmployeeOld>;

  /** A sample resource action that move employee to different location */
  @sharedRoute
  move is ArmResourceActionSync<EmployeeOld, MoveRequest, MoveResponse>;
  /** A sample HEAD operation to check resource existence */
  @sharedRoute
  checkExistence is ArmResourceCheckExistence<EmployeeOld>;
}
```

# Error: deleted a version from your TypeSpec, but didn't delete the associated swaggers?

## question 
For our below PR in azurestackhci
 
[Microsoft.AzureStackHCI API: 2025-12-01-preview by shreyanshd · Pull Request #38737 · Azure/azure-r…](https://github.com/Azure/azure-rest-api-specs/pull/38737)
 
I am seeing typepec validation failure [Microsoft.AzureStackHCI API: 2025-12-01-preview · Azure/azure-rest-api-specs@9f1564a](https://github.com/Azure/azure-rest-api-specs/actions/runs/19847758961/job/56868383940?pr=38737)
 
This versioning I am following in according to Azure versioning  policy
 
[Versioning policy for Azure services, SDKs, and CLI tools | Microsoft Learn](https://learn.microsoft.com/en-us/azure/developer/intro/azure-service-sdk-tool-versioning#preview-versions)
```
  Output folder 'specification/azurestackhci/resource-manager/Microsoft.AzureStackHCI/StackHCI' appears
 to contain TypeSpec-generated swagger files, not generated from the 
current TypeSpec sources. 
Perhaps you deleted a version from your TypeSpec, b
ut didn't delete the associated swaggers?

  

  specification/azurestackhci/resource-manager/Microsoft.AzureStackHCI/StackHCI/
preview/2025-11-01-preview/hci.json

  

  Error: TypeSpec Validation failed for project 
specification/azurestackhci/resource-manager/Microsoft.AzureStackHCI/StackHCI
 run the following command locally to validate.
```

## answer
You should not delete versions from your ARM typespec spec unless those versions are retired and the associated swagger is no longer needed (in which case, you should remove the old swagger as well).  The guidance for a single preview is currently for data plane specs only.  ARM specs will snap to this advice at some point in the near future, but for now,  you should either keep the older typespec preview versions in your spec, or, if they are retired, or were never available to customers, or are not needed for arm registration / api validation, then remove both the swagger and the typespec for them.