# Output folder 'ContentUnderstanding' appears to contain TypeSpec-generated swagger files, not generated from the current TypeSpec sources. Perhaps you deleted a version from your TypeSpec, but didn't delete the associated swaggers?

**Category: TypeSpec Validation**

## question 
[Pull Request #21772](https://github.com/Azure/azure-rest-api-specs-pr/pull/21772) is currently failing TypeSpec validation because data-plane contains the Swagger for an older preview not specified in main.tsp.  The guidance I got from API board a month ago is that main.tsp should only list the latest preview. API version  But doing so triggered this error.
 
Should this be an error?  Or can we make this into a warning instead?

## answer
You should only track the latest preview version in your TypeSpec files.
If there are older preview Swagger files still in the repo, they can remain there for the required 90-day deprecation window, even if they're no longer listed in your .tsp files.

While TypeSpec validation currently throws an error if Swagger files exist without a matching version in TypeSpec, you can suppress this error by adding an entry to suppressions.yaml in your service's spec folder (not the global one).

Longer-term, the goal is to eliminate swagger files entirely, but for now, swagger and TypeSpec coexist. So:

Keep only the latest preview in .tsp

Keep older generated swagger for 90 days

Add suppressions if needed to prevent TypeSpec validation from failing

# Typespec Validation Failing on PR due to `typespec-go` configuration missing

**Category: TypeSpec Validation**

## question 
Hi TypeSpec Discussion, 
CI has been failing constantly for our PR ([Azure Load Testing\] Add 2025-03-01-preview Data-Plane APIs by Harshan01 · Pull Request #32585 · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/pull/32585)) for Typespec Validation step. The logs show that we are missing the Go SDK configuration and I am able to produce this error locally as well. However, our service doesnt have a Go SDK and we are not planning to put it in scope right now. This check has suddenly started failing for our PRs, what should we do?

```
Executing rule：SdkTspConfigVa1idation
[SdkTspconfigVa1idation]：validation failed．
- Failed to find "options.@azure-tools/typespec-go.generate-fakes"．Please add "options.@azure-tools/typespec-go.generate-fakes".
- Failed to find "options.@azure-tools/typespec-go.inject一spans“．Please add "options.@azure-tools/typespec-go.inject一spans.
- Failed to find "options.@azure-tools/typespec-go.service-dir"．Please add "options.@azure-tools/typespec-go.service-dir".
- Failed to find "options.@azure-tools/typespec-go.package-dir"．Please add"options.@azure-tools/typespec-go.package-dir".
Please See https://aka.ms/azsdk/spec-gen-sdk-config for more info．
For additional information on TypeSpec validation, please refer to https://aka.ms/azsdk/specs/typespec-validation.
```

## answer
Suppressing go specific rules worked for me (locally, checking CI now). Thanks Mike. Also FYI Darren Cohen. Here's our suppression file:

```yml
- tool: TypeSpecValidation
  paths:
    - tspconfig.yaml
  rules:
    - SdkTspConfigValidation
  sub-rules:
    # Suppress validation for a Go emitter options
    - options.@azure-tools/typespec-go.generate-fakes
    - options.@azure-tools/typespec-go.inject-spans
    - options.@azure-tools/typespec-go.service-dir
    - options.@azure-tools/typespec-go.package-dir
  reason: 'Azure Load Testing does not support a Go SDK currently'
```
Let me know if I can help with anything!

# SdkTspConfigValidation failures for JS dataplane code generation

**Category: TypeSpec Validation**

## question 
We have a TypeSpec PR here: https://github.com/Azure/azure-rest-api-specs/pull/33130 . We are emitting the new type of JS client library (not RLC), I think it's called dataplane code generation, or modular library, but I'm not sure. We set `is-modular-library: true` in the tspconfig.yaml. However, we're still getting `SdkTspConfigValidation` failures complaining that the word "rest" does not appear in the package name and folder name. See below. I believe that restriction only applies to RLC. I will try to suppress these errors, but checking in here if I'm doing the right thing in tspconfig.yaml, and if so, why do we see these errors? Thanks! Tagging Mike Harder.
```
Executing rule: SdkTspConfigValidation
Skip validation on options.@azure-tools/typespec-go.generate-fakes.
Skip validation on options.@azure-tools/typespec-go.inject-spans.
Skip validation on options.@azure-tools/typespec-go.service-dir.
Skip validation on options.@azure-tools/typespec-go.package-dir.
[SdkTspConfigValidation]: validation failed.
- The value of options.@azure-tools/typespec-ts.package-dir "ai-projects" does not match "/^(?:[a-z]+-)*rest$/". Please update the value of "options.@azure-tools/typespec-ts.package-dir" to match "/^(?:[a-z]+-)*rest$/".
- The value of options.@azure-tools/typespec-ts.package-details.name "@azure/ai-projects" does not match "/^\@azure-rest\/[a-z]+(?:-[a-z]+)*$/". Please update the value of "options.@azure-tools/typespec-ts.package-details.name" to match "/^\@azure-rest\/[a-z]+(?:-[a-z]+)*$/".
Please see https://aka.ms/azsdk/spec-gen-sdk-config for more info.
For additional information on TypeSpec validation, please refer to https://aka.ms/azsdk/specs/typespec-validation.
```

## answer
Yes, you are right the `rest` check should only apply to RLC and I will check if the validation works as expected. One thing to confirm is if we got the JS architects approval to release Modular for AI projects, generally we would recommend to release RLC for data-plane.

# Support for pagination

**Category: Paging**

## question 
Hi, I have a typespec API which is a list api 
```
 listResources is ArmResourceActionSync<
    AutoAction,
    void,
    AutoActionResourceListResponse
  >;

model AutoActionResourceListResponse is Azure.Core.Page<AutoActionResource>;
```
This api needs to support pagination. How can I achieve that using Microsoft.TypeSpec.Providerhub.Controller? we use the package to generate our controllers, which doesn't let me add query parameters to our API

## answer
The controller emitter will emit an endpoint for your action, but you will need to add an endpoint manually for the next page endpoint (which is, presumably, a GET).
get is required for paging.  If you are not using GET, then automated paging mechanisms in ARM clients won't work.
It's possible to use a different paging mechanism, but will require custom code in SDKs
typespec-providerhub does not provide extra GET endpoints for resource actions that return lists - you would need to add this endpoint.  Since the controllers are partial, this should be fairly straightforward.
The question of whether RPaaS (providerhub) should support such an endpoint and typespec-providerhub should provide any required extension support for this is a good one.

# Multiple layers of inheritance for discriminative model

**Category: Decorators**

## question 
Like this
```
@discriminator("discountType")
model DiscountTypeProperties {
  discountType: string;
}

model DiscountTypeCustomPrice extends DiscountTypeProperties {
  discountType: "CustomPrice"
}

model DiscountTypeCustomPriceMultiCurrency extends DiscountTypeCustomPrice {
  discountType: "CustomPriceMultiCurrency";
}
```
DiscountTypeCustomPriceMultiCurrency is extending DiscountTypeCustomPrice, but these two have different discriminator values. How could I represent it?

## answer
this is not supported in TypeSpec with the inheritance based discriminator, I think we talked about that in the past and that was an anti pattern.
You could use discriminated union to represent that instead but I don' think they will be supported in the same way in emitters for now

# Extend ResourceModelWithAllowedPropertySet

**Category: Arm Resource Manager(ARM) Template**

## question 
My customer has this resource definition:
```
"Discount": {
      "type": "object",
      "x-ms-azure-resource": true,
      "description": "Resource definition for Discounts.",
      "allOf": [
        {
          "$ref": "../../../../../common-types/resource-management/v6/types.json#/definitions/ResourceModelWithAllowedPropertySet"
        }
      ],
      "properties": {
        "properties": {
          "description": "Discount properties",
          "x-ms-client-flatten": true,
          "$ref": "#/definitions/DiscountProperties"
        }
      }
    }
```
I tried this TypeSpec
```
@Azure.ResourceManager.Private.armResourceInternal(DiscountProperties)
@TypeSpec.Http.Private.includeInapplicableMetadataInPayload(false)
model Discount extends Azure.ResourceManager.CommonTypes.ResourceModelWithAllowedPropertySet {
  ...ResourceNameParameter<
    Resource = Discount,
    KeyName = "discountName",
    SegmentName = "discounts",
    NamePattern = "^[a-zA-Z0-9_\\-\\.]+$"
  >;

  @doc("The resource-specific properties for this resource.")
  @Azure.ResourceManager.Private.conditionalClientFlatten
  properties: DiscountProperties;
}
```
Error message is: @azure-tools/typespec-azure-resource-manager/arm-resource-invalid-base-type: The @armResourceInternal decorator can only be used on a type that ultimately extends TrackedResource, ProxyResource, or ExtensionResource.
 
I don't quite understand this error, since ResourceModelWithAllowedPropertySet does extend TrackedResource. How could I represent that swagger in TypeSpec?

## answer
We should not use ResourceModelWithAllowedPropertySet.  Instead, we should spread in the appropriate properties using a tracked resource.
 
The ResourceModelWithAllowedPropertySet is meant as an example, not as something resources should use, and so far usage in the specs repo has been incredibly light.  We should not be afraid of this kind of break to make the resulting spec more accurate and easier to evolve over time.

# Non-resource long running operation

**Category: Long Running Operation(LRO)**

## question 
[This](https://github.com/Azure/azure-rest-api-specs/blob/4e8d16d3793228046ac6171eadda4b8d26ad2b4f/specification/botservice/resource-manager/Microsoft.BotService/preview/2023-09-15-preview/botservice.json#L1235) is a long running operation, which is not a resource operation. 
```
    "/subscriptions/{subscriptionId}/providers/Microsoft.BotService/operationresults/{operationResultId}": {
      "get": {
        "tags": [
          "OperationResults"
        ],
        "description": "Get the operation result for a long running operation.",
        "operationId": "OperationResults_Get",
        "x-ms-examples": {
          "Get operation result": {
            "$ref": "./examples/OperationResultsGet.json"
          }
        },
        "parameters": [
          {
            "$ref": "#/parameters/apiVersionParameter"
          },
          {
            "$ref": "#/parameters/subscriptionIdParameter"
          },
          {
            "$ref": "#/parameters/operationResultIdParameter"
          }
        ],
        "responses": {
          "200": {
            "description": "The body contains all of the properties of the operation result.",
            "schema": {
              "$ref": "#/definitions/OperationResultsDescription"
            }
          },
          "202": {
            "description": "Accepted - Get request accepted; the operation will complete asynchronously."
          },
          "default": {
            "description": "Default error response",
            "x-ms-error-response": true,
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        },
        "x-ms-long-running-operation": true
      }
    },
```
This is what I wrote in TypeSpec.

```
@route("/subscriptions/{subscriptionId}/providers/Microsoft.BotService/operationresults/{operationResultId}")
  @get
  get(
    ...ApiVersionParameter,
    ...SubscriptionIdParameter,

    /**
     * The ID of the operation result to get.
     */
    @path
    operationResultId: string,
  ): ArmResponse<MoveResponse> | ArmAcceptedLroResponse<LroHeaders = ArmLroLocationHeader<FinalResult = MovedResponse> &
  Azure.Core.Foundations.RetryAfterHeader> | ErrorResponse;
```
It's still not LRO. How could I represent this operation in TypeSpec?

## answer
long-running GET is not allowed in ARM, or in Azure at all.  We should not support any such operation, this is undoubtedly a mistake, if it appears in any spec.
It would be allowed to do a non-resource POST operation, which you might model like this:
```
/** A ContosoProviderHub resource */
model Employee is TrackedResource<EmployeeProperties> {
  ...ResourceNameParameter<Employee>;
}

/** Employee properties */
model EmployeeProperties {
  /** Age of employee */
  age?: int32;

  /** City of employee */
  city?: string;

  /** Profile of employee */
  @encode("base64url")
  profile?: bytes;

  /** The status of the last operation. */
  @visibility(Lifecycle.Read)
  provisioningState?: ProvisioningState;
}

/** The provisioning state of a resource. */
@lroStatus
union ProvisioningState {
  string,

  /** The resource create request has been accepted */
  Accepted: "Accepted",

  /** The resource is being provisioned */
  Provisioning: "Provisioning",

  /** The resource is updating */
  Updating: "Updating",

  /** Resource has been created. */
  Succeeded: "Succeeded",

  /** Resource creation failed. */
  Failed: "Failed",

  /** Resource creation was canceled. */
  Canceled: "Canceled",

  /** The resource is being deleted */
  Deleting: "Deleting",
}

/** Employee move request */
model MoveRequest {
  /** The moving from location */
  from: string;

  /** The moving to location */
  to: string;
}

/** Employee move response */
model MoveResponse {
  /** The status of the move */
  movingStatus: string;
}

interface Operations extends Azure.ResourceManager.Operations {}

@armResourceOperations
interface Employees {
  get is ArmResourceRead<Employee>;
  createOrUpdate is ArmResourceCreateOrReplaceAsync<Employee>;
  update is ArmCustomPatchSync<
    Employee,
    Azure.ResourceManager.Foundations.ResourceUpdateModel<
      Employee,
      EmployeeProperties
    >
  >;
  delete is ArmResourceDeleteWithoutOkAsync<Employee>;
  listByResourceGroup is ArmResourceListByParent<Employee>;
  listBySubscription is ArmListBySubscription<Employee>;

  /** A sample resource action that move employee to different location */
  move is ArmResourceActionSync<Employee, MoveRequest, MoveResponse>;

  /** long-running get statistics */
  getStatistics is ArmProviderActionAsync<
    void,
    {
      ...OkResponse;
    },
    SubscriptionActionScope
  >;

  /** A sample HEAD operation to check resource existence */
  checkExistence is ArmResourceCheckExistence<Employee>;
}
```
But, in this case, this looks like they are modeling a subscription-level operationResult resource, which should just be modeled as a resource operation get that is not long-running.
 

# Extending 'Azure.ResourceManager.CommonTypes.ProxyResource' that doesn't define a discriminator.

**Category: Decorators**

## question 
Like this. I got warning
```
Model 'Employee' is extending 'Azure.ResourceManager.CommonTypes.ProxyResource' that doesn't define a discriminator. If 'Azure.ResourceManager.CommonTypes.ProxyResource' is meant to be used: - For composition consider using spread `...` or `model is` instead. - As a polymorphic relation, add the `@discriminator` decorator on the base model.
```
Why this gets related to discriminator?

## answer
In general we want to discourage any use of in inheritance if not used with discriminator hence the warning. I assume you have to do this because there is a non standard resource tghat can't do `model is ProxyResource`? If so probably have to suppress that too

# Model validation failures - Newer models introduced in new version adds the parent models in the older version.

**Category: Versioning**

## question 
Hi team!
 
I am trying to create a new version with a new models only specific to the latest version. I have also added the @added attribute to it. 
 
Despite this it is adding the models from the parent model - here (Recomendation, MigrationIssues, MigrationSuitability, etc) to all the older versions of the swagger which is not an intended behaviour.
 
Added the model implementation for more context. and adding the PR for a more broader context. 

[WACA changes for assessedWebApps by alphaNewrex · Pull Request #22616 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/22616/files)

```
@doc("Compound Assessment Recommendations.")
@added(WACAApiVersions.v2025_03_30_preview)
model CompoundAssessmentRecommendations
  is Recommendations<
    MigrationIssues,
    MigrationSuitability,
    Skus<MigrationSuitability>
  > {
  @doc("Arm id of the assessed resource. to get extended details.")
  extendedDetailsAssessedResourceArmId: string;
}
```

## answer
Yes, `@added` does not process a tree of models,  any model you introduce will have to be versioned in the same way (so all of those models would need their own `@added` decorators).

# Duplicate Example files for Typespec and other for Swagger. By design?

**Category: SDK Generation**

## question 
Following folder have same 54 files of example json. Is it by design?
- specification\apicenter\ApiCenter.Management\examples\2024-06-01-preview
- specification\apicenter\resource-manager\Microsoft.ApiCenter\preview\2024-06-01-preview\examples

## answer
Yes.  The example files in the OpenAPI directory are automatically copied when you compile the spec, they are essentially part of the emitted OpenAPI

# Override contentType: "application/json" for ResourceCreateOrUpdate

**Category: Operations**

## question
Hi TypeSpec Discussion,
I am migrating an old swagger to typespec. I came across a method which is a PATCH ops with a application/json as content type. The API behaves exactly as a merge-patch route, but I cannot change it since it'll be consider a breaking change. In order to still use the convenient functionalities of typespec traits, I have define a custom function like this and am using it.
```
// --------------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// --------------------------------------------------------------------------------------------

import "@typespec/rest";
import "@typespec/versioning";
import "@typespec/http";
import "@typespec/openapi";
import "@azure-tools/typespec-azure-core";

using TypeSpec.Http;
using TypeSpec.Rest;
using Azure.Core;
using Azure.Core.Traits;

namespace Azure;

#suppress "@azure-tools/typespec-azure-core/no-private-usage" ""
@Foundations.Private.ensureVerb("ResourceCreateOrUpdate", "PATCH")
@createsOrUpdatesResource(Resource)
@parameterVisibility(Lifecycle.Create, Lifecycle.Update)
@patch
op ResourceCreateOrUpdateWithJsonContentType<
  Resource extends TypeSpec.Reflection.Model,
  Traits extends TypeSpec.Reflection.Model = {},
  InterfaceTraits extends TypeSpec.Reflection.Model = {},
  ErrorResponse = Azure.Core.Foundations.ErrorResponse
> is Azure.Core.Foundations.ResourceOperation<
  Resource,
  {
    /**
     * The name of the project to use.
     */
    @doc("This request has a JSON body.")
    @TypeSpec.Http.header("Content-Type")
    contentType: "application/json";

    ...Foundations.ResourceBody<Resource>;
    ...Azure.Core.Traits.Private.TraitProperties<
      Traits & InterfaceTraits,
      TraitLocation.Parameters,
      TraitContext.Create | TraitContext.Update
    >;
  },
  Azure.Core.Foundations.ResourceCreatedOrOkResponse<Resource &
    Azure.Core.Traits.Private.TraitProperties<
      Traits & InterfaceTraits,
      TraitLocation.Response,
      TraitContext.Create | TraitContext.Update
    >>,
  Traits & InterfaceTraits,
  ErrorResponse
>;

```
Is there a better alternative?

## answer
Yes. it's expected that if you are using a non-standard content-type for PATCH you will need to use a custom operation or a custom operation template.

# Customizing key for child operation

**Category: Decorators**

## question 
Is there a way to customize the key of a parent resource for a specific child operation?
 
In SDKs we are being asked to change the name, but I couldn't find a good place to apply the `@clientName` decorator.

## answer   
In the data plane API, resource keys are typically derived from the parent resource’s key and are not individually specified for each operation. By default, the key names for operations are inherited from the parent resource's key. The @clientName decorator is used to modify the name used by the client, not to change the parent resource's key in operations. To change the parent resource's key name globally, the simplest solution is to use the @key decorator on the name property to ensure consistency.

Changing the key name specifically for certain operations is not straightforward because operation keys are typically tied to the parent resource key. Although you can explicitly define different keys for an operation, this generally requires redefining the operation.

In your case, the most reasonable approach would be to update the parent resource's key name to jobName across all operations to maintain consistency rather than using a different name for some operations. This approach reduces naming conflicts and ensures consistency.

For how to explicitly specify key definitions, you can refer to the Azure Data Plane documentation, which outlines how to define keys for each service's operations and resources.

# Default value starting from a specific API version?

**Category: Versioning**

## question 
Hello, we currently have a property (StatelessServiceProperties,minInstancePercentage) that does not currently have a default value in our spec, but in practice is treated as if it is 0. We would like to treat the default prior to 2025-06-01 as 0, then as a different value from 2025-06-01 onward in our service.
1. We haven't changed the default for an existing property before. Are there concerns about this intended behavior? 
2. In Typespec, is it possible to add a default value in our spec from a specific api version (say 2025-06-01) onward?

## answer
I think you need to run this change by the breaking change board, as a change in the default may be breaking, depending on the details.  Also, the most important thing is to make sure that the API description accurately reflects service behavior - if the default has always been in place, for example, it may be better to just change the default and go through the breaking change process.  Yes, it is possible to do this in TypeSpec, but involves removing and renaming the old property and adding a new property with the new default, like this
```
/** Employee properties */
model EmployeeProperties {
  /** Age of employee */
  @removed(Versions.`2024-11-01-preview`)
  @renamedFrom(Versions.`2024-11-01-preview`, "age")
  formerAge?: int32;

  /** Age of employee */
  @added(Versions.`2024-11-01-preview`)
  age?: int32 = 21;
}
```

# Does TypeSpec support example generation for new added versions?

**Category: SDK Generation**

## question 
Hi team, when adding a new api version in the TypeSpec, is there any way I can generate thoes example Json files from preview version and with the "api-version" property changed? Or I will need to manually cope the example Json files from preview version and update the "api-version" property inside all of them?

## answer
Example generation for specs works the same way as it did before.
You will need to place version specific examples under `examples\[version]`. So if you are adding a new version, you can copy over the example files and make appropriate add/remove/update to them including the `api-version`
Note that you can also use swagger-based example generation, for the new version (which is less attractive if you have customized the examples)

# Description changes across versions?

**Category: Versioning**

## question 
Hi, as part of this PR: [Service Fabric Managed Clusters - API version 2025-03-01-preview · Azure/azure-rest-api-specs@599e269](https://github.com/Azure/azure-rest-api-specs/actions/runs/14090043123/job/39464153437?pr=33332)

My team wanted to add more details to a model description. This change results in a change in all spec versions generated with Typespec, and causes the Typespec validation to fail if I don't include the changes to the older specs. 
 
I wanted to know what the best course of action was for passing this check. Since we don't expect updates to our older specs, is it ok to just change the output path in our tspconfig.yaml to only point at the current version of the output spec? Or is there a better way to handle this?

## answer
Honestly, the best thing is to update your docs and take the update in previous versions (which are likely now more accurately described as well). Documentation-only updates should not be flagged as breaking changes at all. If they are for some reason, I'll just approve it.  

# Typespec Validation issue

**Category: TypeSpec Validation**

## question 
I've a PR where the Typespec validation is failing with some weird error. This is not being reproduced locally - 
```
  specification/storagedatamanagementrp/Private.StorageDataManagement.Management/main.tsp:17:10 - error expect-value: Is a model expression type, but is being used as a value here. Use #{} to create an object value.
53  > 17 | @service({
54       |          ^
55  > 18 |   title: "Storage Data Management Resource Provider",
56       | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
57  > 19 | })
58       | ^^
```
```
specification/storagedatamanagementrp/Private.StorageDataManagement.Management/Connectors/connectorModels.tsp:19:15 - error invalid-argument: Argument of type '"read"' is not assignable to parameter of type 'valueof EnumMember'
60  > 19 |   @visibility("read")
61       |               ^^^^^^
```
I'm not sure how to resolve this error. Could someone please help here?
[Update Connector and DataShare Swagger by ujjawaljain-msft · Pull Request #21997 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/21997)

## answer
You may need to update to the latest typespec version - some of these particular properties have changed in a recent version. What you are using here isn't the latest style to specify these things.
Doc for future reference: https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally :

```
Running Locally
To ensure you see the same results from TypeSpecValidation in your PR check and tsv on your local machine:
Merge latest from parent (e.g. main or RPSaaSMaster) to your PR branch
Run locally
git clean -xdf (may revert any local changes)
git pull
npm ci
npx tsv specification/contosowidgetmanager/Contoso.Management
git status
If any changes, git add, git commit, git push to update your PR.
If you are still having problems, try cloning your branch to a new folder, or try on another machine.
If the problem can be reproduced on a clean machine, request assistance from the TypeSpec Discussion teams channel.
```

# Seeking Guidance on Defining ResourceStatusCode in TypeSpec

**Category: Decorators**

## question 
Hello 
TypeSpec Discussion
I am working on defining a `ResourceStatusCode` in TypeSpec, which is similar to HTTP status codes but specific to resource states. I would appreciate your guidance on the following:
1. Should I use an `enum` or a `int` to define the `ResourceStatusCode`?
2. What are the best practices for defining status codes in TypeSpec?
3. How can I ensure that the `ResourceStatusCode` remains extensible for future updates?
I want to add statuses like:
- `NotSpecified: 204 No Content` - This indicates that the request was successful, but there is no content to return.
- `Pending: 102 Processing` - This indicates that the server has received and is processing the request, but no response is available yet.
- `Running: 202 Accepted` - This indicates that the request has been accepted for processing, but the processing has not been completed.
- `Succeeded: 200 OK` - This indicates that the request has succeeded.
- `Failed: 500 Internal Server Error` - This indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.

Thank you for your assistance.

## answer
As per one of our previous understanding, we defined similarly as an open union: [azure-rest-api-specs-pr/specification/impact/Impact.Management/connectors.tsp at RPSaaSMaster · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/blob/RPSaaSMaster/specification/impact/Impact.Management/connectors.tsp#L88-L94).  
```
@doc("Enum for connector types")
union Platform {
  string,

  @doc("Type of Azure Monitor")
  AzureMonitor: "AzureMonitor",
}
```
This explicitly allows any string value.
 
Generally, the reason for doing this is that you think additional values will be enabled in future versions (or even in this version).  Note that, if you do not make this an open union, then adding any values in any future api-version would be a breaking change (which is why this is recommended).
 
There are RPaaS extensions for validation that would allow you to reject requests for values that are not valid.

# Update API definition in typespec-providerhub

**Category: Operations**

## question 
Hi team, I'm using [providerhub template](https://armwiki.azurewebsites.net/rpaas/gettingstarted.html#bootstrap-your-development-with-typespec-formerly-cadl) to generate a new RP, when trying to add custom API(simple health check for testing) in main.tsp, after build it doesn't generate the new model and controllers that I added, does the template have restrictions on what kind of APIs can be added? Here's what I tried to add into typespec.

```
// Add the health check operation
@doc("Health check endpoint to verify the service is running.")
model HealthCheckResponse {
  message: string;
}

interface HealthCheck {
  @get
  @route("/api/healthcheck")
  @doc("Returns a simple message indicating the service is running.")
  healthCheck(): HealthCheckResponse;
}
```

## answer
Yes, the emitter is specifically about generating RPaaS extensions, not about generating APIs.  You should be able to generate the model, however from your spec.
 
The emitter only updates a specific set of folders, so you can write your own controllers for any APIs outside of generated extensions, and just be sure not to place them in the folder with generated artifacts.

# How to properly update the TypeSpec environment?

**Category: TypeSpec Validation**

## question 
I tried inferring steps from the various installation documents but just managed to break my environment and have no idea how to fix it.
 
I saw a recent post where it was said to run `npm install -g @typespec/compiler` to get the latest (0.66) but it looks like it did not work for me. My compiler is still 0.64.
```
NORTHAMERICA+darkoa@darkoa-ws MINGW64 /d/Dev/Projects/git/github/azure-rest-api-specs-pr (RPSaaSMaster)
$ npm install -g @typespec/compiler

changed 268 packages in 11s

34 packages are looking for funding
  run `npm fund` for details

NORTHAMERICA+darkoa@darkoa-ws MINGW64 /d/Dev/Projects/git/github/azure-rest-api-specs-pr (RPSaaSMaster)
$ tsp compile specification/deviceupdate/DeviceUpdate.Edge.Management/
TypeSpec compiler v0.64.0

Diagnostics were reported during compilation:
```
I get a bunch of errors, although we made no changes recently. I am guessing those changes were made by the TypeSpec team and I am also guessing that if I manage to properly update tools, the errors should go away.
 
So, is there a single document that describes how to update the environment to the latest?

## answer
The issue you're facing is related to updating your local TypeSpec environment. Here's a summary of the solution:

Update Local Dependencies:

Running npm install -g @typespec/compiler only updates the global TypeSpec compiler, which is not typically used for local development unless you need access to TypeSpec commands globally.

To properly update your local environment, navigate to your repository and run npm ci. This command installs the exact versions of dependencies specified in the package-lock.json, ensuring consistency.

TypeSpec Versions in Repositories:

When working with repositories like azure-rest-api-specs, you should always install dependencies based on the local package.json and package-lock.json at the root of your branch. This ensures you're using the correct version of TypeSpec and associated tools for your current project.

Dealing with Configuration Warnings:

The warnings you're seeing (such as missing options for SDK emitters) are configuration-related, not errors. These warnings appear when SDK emitters for specific languages (like Go, Python, C#) are not installed, but they do not affect your immediate work with TypeSpec validation. These can be safely ignored unless you need to work with SDK generation.

Suppression and Documentation:

If you want to suppress specific warnings, you can modify the suppressions.yaml file, but it's important to follow the TypeSpec guidelines to ensure proper environment configuration.

# How to restrict importing typespec files in main based off of versions.

**Category: Versioning**

## question 
Hi Team,
We have 2 imports in our main.tsp to include other resource type tsp files, however we do not want to include one of the resourcetype to the new api version we want to introduce.  Is there a way to do conditional imports based off of version in main?
 
Thank you in advance!
## answer
no, you have to mark the models/types and everything that you want to remove with the @removed decorator using the versioning library
 
if you are in preview version I think also the policy is to only have a single preview version in the spec repo at the timme now so you could also just delete it

# Brownfield TypeSpec migration

**Category: TypeSpec Migration**

## question 
Hi, Is there a timeframe for existing brownfield RPs to move from OpenAPI swagger to TypeSpec.  Is it possible to mix TypeSpec with handwritten swagger and migrate in phases. Say for example migrate one resource type at a time to minimize risk. 

## answer
Migration to TypeSpec for existing services is not yet mandatory, but it is suggested, and teams should be planning for it in Bromine and Krypton
Services must wholly switch to TypeSpec, there is no allowed mixing of hand-written and generated swagger
Servicesmust conform to a single, unified api-version for their service, servicesthat currently use different api-versions for parts of their service are going to need to plan for conformance -this either means SDK splitting or version uniformity.  Teams that use this 'different api-versions for different resources in the same sdk' pattern are not good candidates for conversion at the moment
In generally, the more compliant your service is to the RPC and best practices, the easier conversion will be
There is documentation on converting here: [Getting started | TypeSpec Azure](https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started/)

We highly encourage you do the migration. Any problem related to https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started/, don't hesitate to reach out to me.
 
# Setting default value for a union type for only some API versions

**Category: Versioning**

## question 
Hi team,
Is it possible to set default value for a union type for only some API versions?
 
For below union type, I want to set default value as ApprovalStatus.Pending from API version 2024-12-01-preview onwards. Is this possible?

```
@doc("Approval Status Enum")
union ApprovalStatus {
  @doc("ApprovalStatus Type Approved")
  Approved: "Approved",

  @doc("ApprovalStatus Type Rejected")
  Rejected: "Rejected",

  @doc("ApprovalStatus Type Pending")
  Pending: "Pending",

  @added(Microsoft.Mission.Versions.v2024_11_01_preview)
  @doc("ApprovalStatus Type Deleted")
  Deleted: "Deleted",

  @added(Microsoft.Mission.Versions.v2024_11_01_preview)
  @doc("ApprovalStatus Type Expired")
  Expired: "Expired",

  string,
}
```

## answer
From a purely "what is the TypeSpec syntax for assigning a default value to a type", no, I don't think we have any way of doing this. You can create a reusable property that you can spread into various places if that is what you are trying to accomplish.
 
From a service API design perspective, what actually changed between the API versions? The pending status was already there in older API versions. Presumably the property that had a type of ApprovalStatus always created things in a pending state (it looks like this is a type that would be used in a persisted model/resource). Wasn't that always conceptually pending? 
I think that shouldn't a problem on the breaking change part. 

# Readonly on model

**Category: TypeSpec Migration**

## question 
We have such swagger
```
"ReadonlyOnModel": {
  readonly: true,
  properties: {}
},
"AnotherModel": {
  properties: {
    "a": {
      $ref: "ReadonlyOnModel"
    }
  }
}
```
When the type of property "a" in another model is that "ReadonlyOnModel", M4 will give a readonly on that property "a". I want to confirm if the equivalent TypeSpec should be
```
model AnotherModel {
  @visibility(Lifecycle.Read)
  a: ReadonlyOnModel;
}
model ReadonlyOnModel {}
```
cc Alitzel Mendez : Common type replacement relates to this. I remember we have several models in the original common type have readonly on them and you removed these because TypeSpec cannot represent readonly on model. Then if any service refers to this model, those properties might need to be updated.

## answer
TypeSpec can only attach readOnly to properties, not to models or scalars.  Functionally (assuming all references to ReadOnlyModel are through readOnly properties),  these Swagger docs are equivalent, see: [autorest/docs/openapi/howto/$ref-siblings.md at main · Azure/autorest](https://github.com/Azure/autorest/blob/main/docs/openapi/howto/%24ref-siblings.md) from the perspective of both TypeSpec and autorest, these descriptions are equivalent.
 
# Exclude property from list that is in create/update/get

**Category: Operations**

## question 
We have an ARM resource that has a property , e.g.  properties.blob that will contain a very large amount of text not appropriate for list responses. 
 
I see we can override the properties for ArmResourceCreateOrReplaceAsync and ArmResourcePatchAsync, but I don't see a way to do this for ArmResourceRead or ArmResourceListByParent.
 
Is there a way to exclude a property from properties when listing other than defining a new resource type that lacks the specific property?
 
The property is required. The only way I can see to do this would be to make it appear optional but return an error is the user tried to set it to empty or null.

## answer
First, has this been through ARM Review?  Having a very large piece of data as part of a resource could present issues.
 
To answer the question, you can change the response type for a list operation using the `Response` parameter, ```
@armResourceOperations
interface Employees {
  #suppress "@azure-tools/typespec-azure-resource-manager/arm-resource-operation-response"
  listByResourceGroup is ArmResourceListByParent<
    Employee,
    Response = EmployeeListResult
  >;
  #suppress "@azure-tools/typespec-azure-resource-manager/arm-resource-operation-response"
  listBySubscription is ArmListBySubscription<
    Employee,
    Response = EmployeeListResult
  >;
}
```

# Additional OKResponse

**Category: Long Running Operation(LRO)**

## question 
Like
```
@armResourceOperations
interface Employees {

  /** A sample resource action that move employee to different location */
  move is ArmResourceActionAsync<Employee, MoveRequest, OkResponse>;
}
```
My expected response is
```
"200": {
 "description": "ignore"
},
"202": {
 "description": "ignore"
},
"default": {
  "description": "ignore",
    "schema": {
    "$ref": "../../../../../common-types/resource-management/v5/types.json#/definitions/ErrorResponse"
  }
}
```
And it is lro. Therefore I wrote this TypeSpec
```
move is ArmResourceActionAsync<Employee, MoveRequest, OkResponse>;
```
However, this will emit a useless model `TypeSpec.Http.OkResponse` which causes problems in downstream. Can we remove this model? (omit-unreachable-types: true does not work)

## answer
If the `OkResponse` model is being emitted but not actually referenced, that does sound like a bug — we shouldn't be generating unused models. Especially in cases like this where you're doing a long-running POST action and the 200 response is effectively empty, it’s more accurate to model the operation with just a `202` and an error response.

For your case, you can avoid using `OkResponse` entirely by switching to `ArmResourceActionNoResponseContentAsync` or passing `never` as the third argument. That will prevent the generation of the unnecessary `OkResponse` model.

Also, keep in mind that for LROs, the POST operation typically doesn't return 200 anyway. That response is just a placeholder in the old pattern to signal "void". If you're converting from existing Swagger, and it doesn’t actually return 200, you should be able to safely drop that response from the Swagger and avoid the breaking change.

Alternatively, if you do need to customize the final response for the LRO, `getLroResponse` can be used to override the response returned at the end of the operation — no need to rely on `OkResponse` at all.

 
# TSP Install fails with below error

**Category: TypeSpec Validation**

## question 
I am trying to install TSP and its dependencies and it fails with below error. I have latest node.js Can you please help?

Error: spawn EINVAL
    at ChildProcess.spawn (node:internal/child_process:420:11)
    at spawn (node:child_process:753:9)
    at installTypeSpecDependencies (file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/dist/src/core/install.js:4:19)
    at file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/dist/src/core/cli/cli.js:152:95
    at Object.handler (file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/dist/src/core/cli/utils.js:16:16)
    at file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/node_modules/yargs/build/lib/command.js:206:54
    at maybeAsyncResult (file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/node_modules/yargs/build/lib/utils/maybe-async-result.js:9:15)
    at CommandInstance.handleValidationAndGetResult (file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/node_modules/yargs/build/lib/command.js:205:25)
    at CommandInstance.applyMiddlewareAndGetResult (file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/node_modules/yargs/build/lib/command.js:245:20)
    at CommandInstance.runCommand (file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/node_modules/yargs/build/lib/command.js:128:20) {
  errno: -4071,
  code: 'EINVAL',
  syscall: 'spawn'
}

## answer
1. which version of the compiler did you install globally, this looks liek quite an old one?
2. where are you trying to use typespec, if its the azure spec repo please follow the docs there https://github.com/Azure/azure-rest-api-specs/blob/7fc6689d84858b1c71b786526b04c014c4589968/documentation/typespec-rest-api-dev-process.md

# Augmented decorators on resource in the multi-path scenario

**Category: Decorators**

## question 
This is a resource [model](https://github.com/Azure/azure-rest-api-specs/blob/3a8d2effa54913b5f5365e9a4610810825366409/specification/notificationhubs/Notificationhubs.Management/SharedAccessAuthorizationRuleResource.tsp#L18) 
```
@parentResource(NotificationHubResource)
model SharedAccessAuthorizationRuleResource
  is Azure.ResourceManager.TrackedResource<SharedAccessAuthorizationRuleProperties> {
  ...ResourceNameParameter<
    Resource = SharedAccessAuthorizationRuleResource,
    KeyName = "authorizationRuleName",
    SegmentName = "authorizationRules",
    NamePattern = "^[a-zA-Z0-9!()*-._]+$"
  >;
}
```
in the multi-path scenario. It wants to have [minLength and maxLength](https://github.com/Azure/azure-rest-api-specs/blob/3a8d2effa54913b5f5365e9a4610810825366409/specification/notificationhubs/Notificationhubs.Management/SharedAccessAuthorizationRuleResource.tsp#L179-L180).
```
@@maxLength(SharedAccessAuthorizationRuleResource.name, 256);
@@minLength(SharedAccessAuthorizationRuleResource.name, 1);
```
 Its [parent](https://github.com/Azure/azure-rest-api-specs/blob/3a8d2effa54913b5f5365e9a4610810825366409/specification/notificationhubs/Notificationhubs.Management/NotificationHubResource.tsp#L18) 
```
@parentResource(NamespaceResource)
model NotificationHubResource
  is Azure.ResourceManager.TrackedResource<NotificationHubProperties> {
  ...ResourceNameParameter<
    Resource = NotificationHubResource,
    KeyName = "notificationHubName",
    SegmentName = "notificationHubs",
    NamePattern = "^[a-zA-Z][a-zA-Z0-9-./_]*$"
  >;
```
also has [augmented decorator](https://github.com/Azure/azure-rest-api-specs/blob/3a8d2effa54913b5f5365e9a4610810825366409/specification/notificationhubs/Notificationhubs.Management/NotificationHubResource.tsp#L116-L117) 
```
@@maxLength(NotificationHubResource.name, 265);
@@minLength(NotificationHubResource.name, 1);
```
on it. 
 
Actual: No minLength and maxLength [at generated parameter](https://github.com/Azure/azure-rest-api-specs/blob/3a8d2effa54913b5f5365e9a4610810825366409/specification/notificationhubs/resource-manager/Microsoft.NotificationHubs/preview/2023-10-01-preview/notificationhubs.json#L1286-L1308). 
```
{
            "name": "namespaceName",
            "in": "path",
            "description": "The name of the NamespaceResource",
            "required": true,
            "type": "string",
            "pattern": "^[a-zA-Z][a-zA-Z0-9-]*$"
          },
          {
            "name": "notificationHubName",
            "in": "path",
            "description": "The name of the NotificationHubResource",
            "required": true,
            "type": "string",
            "pattern": "^[a-zA-Z][a-zA-Z0-9-./_]*$"
          },
          {
            "name": "authorizationRuleName",
            "in": "path",
            "description": "The name of the SharedAccessAuthorizationRuleResource",
            "required": true,
            "type": "string",
            "pattern": "^[a-zA-Z0-9!()*-._]+$"
```
Expected: [This](https://github.com/Azure/azure-rest-api-specs/blob/5351ac8e1e6fdf48933bae2cd879434b93b36ac0/specification/notificationhubs/resource-manager/Microsoft.NotificationHubs/preview/2023-10-01-preview/notificationhubs.json#L417-L425) 
```
{
            "$ref": "#/parameters/NamespaceName"
          },
          {
            "$ref": "#/parameters/HubName"
          },
          {
            "$ref": "#/parameters/AuthorizationRuleName"
          },
```
is the original swagger. There is limitations on minLength and maxLength.

## answer
Yes, because the actual path parameters do not come from the resource, you would need to decorate the parameters in the LegacyOperations instantiation.

When you construct the LegacyOperations interface, you pass in the parameters - those passed-in parameters would need to be decorated.
 
I wonder if we shouldn't have a legacy resource template that omits the name parameter, just to avoid confusion, it is literally unused in this context.

If you need to decorate the name parameter, you will need to define them directly, or name the resulting model, so they can be decoratred.  You can decorate a model statement, but not a model expression.
 
# First experience of TSP ApiVersion introduction - passed all CI checks, what's next?

**Category: Versioning**

## question 
Hi TypeSpec friends! 
 
We are bringing 2nd "private-preview" API version to exercise TSP-based wirings and learn the ecosystem:
https://github.com/Azure/azure-rest-api-specs-pr/pull/22321
 
First round was back in the swagger days.
Now that we are bringing TSP, it comes with a lot of learning.
We made lots of adjustments to satisfy the checks, that were not really changing the protocol, and we had to apply several suppressions otherwise since development of this version has completed - and it is heading to PowerShell CLI partners.
 
It is clear that specification work of the next API version need to be exercised through Azure REST repository tooling to flip the process around, and be able to make protocol affecting changes.
 
With that said - with all checks satisfied - except for "Automated merging requirements met" - what is the next step to bring this PR into the review loop?
 
Updated based on the review comments:

1) for comment [about metadata](https://github.com/Azure/azure-rest-api-specs-pr/pull/22321#discussion_r2072077880)

we have:
```
  @doc("The metadata")
  metadata?: Record<string>;
```
suggestion was: Consider using array of KVP
 
my follow up suggestion: our desired over-the-wire representation is { "mykey": "myvalue" }
can we achieve that via below, will that be supported:
```
model MetadataModel {  [key: string]: string;}
```
2) regarding a [question for the purpose of the PR](https://github.com/Azure/azure-rest-api-specs-pr/pull/22321#issuecomment-2847987559) - I provided brief [answer](https://github.com/Azure/azure-rest-api-specs-pr/pull/22321#issuecomment-2848108430), can you please share the "control plane template" form for me to fill?
 
3) for the initatorId property [question](https://github.com/Azure/azure-rest-api-specs-pr/pull/22321#discussion_r2072077812) - I answered it, not sure if I should put all of my answer in the @doc, since some of that doesn't have to be public facing. Would a regular comment be of help for reviewers, something that is otherwise invisible to the swagger?
 
4) there was a [recommendation](https://github.com/Azure/azure-rest-api-specs-pr/pull/22321#discussion_r2072053387) on how operation ids should look like - and my question was how do we control operation ids, since I am not seeing TSP code of ours being responsible for operation id strings that end up in the swagger?

## answer
Some thoughts:
1. That issue isn't how to get Typespec to construct that over-the-wire pattern. The issue is that the dictionary pattern is an ARM anti-pattern. It defeats important ARM features that customers expect to be able to use (ARG, and Azure Policy). There are other issues with this pattern: (how are the supported keys documented, how are the supported keys versioned, how do clients determine what keys are required vs. optional, etc.).
2. You can create a new dummy PR in github to get a template file and add it to your existing PR. If you use the link to create the PR, Github automatically adds the template file.
3. The type of that property was string. The suggestion is to use the name and @doc to help clients understand what that string represents and how to correctly populate it. It's up to you how much to share about internals.
4. This appears to be the only TypeSpec Discussion question here. I don't know the answer.
Follow-up on items 1-3 above should be in PR comments rather than here. Current on-call reviewer will follow up.

# Namespace when not specified?

**Category: SDK Generation**

## question 
[azure-rest-api-specs/specification/ai/Face/tspconfig.yaml at main · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/ai/Face/tspconfig.yaml)
```
parameters:
  "service-dir":
    default: "sdk/face"
  "dependencies":
    default: ""
emit:
  - "@azure-tools/typespec-autorest"
options:
  "@azure-tools/typespec-autorest":
    azure-resource-provider-folder: "data-plane"
    emit-lro-options: "none"
    emitter-output-dir: "{project-root}/.."
    omit-unreachable-types: true
    output-file: "{azure-resource-provider-folder}/{service-name}/{version-status}/{version}/Face.json"
  "@azure-tools/typespec-python":
    package-dir: "azure-ai-vision-face"
    namespace: "azure.ai.vision.face"
    package-version: 1.0.0b2
    package-mode: dataplane
    flavor: azure
    generate-test: true
    generate-sample: true
  "@azure-tools/typespec-csharp":
    package-dir: "Azure.AI.Vision.Face"
    namespace: "{package-dir}"
    clear-output-folder: true
    model-namespace: false
    flavor: azure
  "@azure-typespec/http-client-csharp":
    namespace: Azure.AI.Vision.Face
    model-namespace: false
  "@azure-tools/typespec-ts":
    package-dir: "ai-vision-face-rest"
    generate-metadata: true
    flavor: azure
    package-details:
      name: "@azure-rest/ai-vision-face"
      description: "Face API REST Client"
  "@azure-tools/typespec-java":
    package-dir: "azure-ai-vision-face"
    namespace: com.azure.ai.vision.face
    partial-update: true
    use-eclipse-language-server: false
    enable-subclient: true
    generate-samples: false
    generate-tests: false
    flavor: azure
linter:
  extends:
    - "@azure-tools/typespec-azure-rulesets/data-plane"
  disable:
    "@azure-tools/typespec-azure-core/operation-missing-api-version": "API version located in the host template"
    "@azure-tools/typespec-azure-core/use-standard-operations": "Most of our operation doesn't fit standard ops"
    "@azure-tools/typespec-azure-core/use-standard-names": "Most of our operation doesn't fit standard ops"
```
I'm working on adding Tier 1 language namespace names to TypeSpec APIView. I can get this from the compiler options when namespace is specified in the tspconfig.yaml. However, what should the behavior be when, as in the above config, the namespace isn't specified (for typespec-ts)?  What heuristic is applied to determine the namespace? Is it language specific?

## answer
When the `namespace` isn't explicitly specified in `tspconfig.yaml`, the behavior falls back to what's defined in the TypeSpec file itself—i.e., whatever `namespace` is declared there. If no namespace is declared in the TypeSpec, then the emitter determines the default, which may vary by language.

In the management plane, it's fairly standardized: we derive the namespace based on the resource provider name, stripping prefixes like `Azure` or `Microsoft`, flattening separators, and applying language-specific naming conventions. For example:

* .NET: `Azure.ResourceManager.[ProviderName]`
* Python: `azure-mgmt-[providername]`
* Java: `com.azure.resourcemanager.[providername]`
* JS: `@azure/arm-[providername]`

For **data plane**, it's similar but instead of "ResourceManager", you use the service group (like `AI`, `Data`, etc.). By default, it uses the namespace from the TypeSpec unless you override it via:

```yaml
namespace: Azure.LoadTesting
```

in the `tspconfig.yaml`. That flag overrides the namespace across all language emitters.

There was some confusion with how this gets surfaced through TCGC. Although `clients[0].namespace` is supposed to reflect the effective namespace, it wasn't showing the expected value (`azure.ai.vision.face`). Isabella helped identify the issue and confirm that it was due to a workaround or emitter configuration not being applied as expected.
 
# Resource Action LRO response modelling

**Category: Long Running Operation(LRO)**

## question 
I want to define an Async resource action. Calling this action doesn't produce a  body in the immediate response, but the  long running operation will have a body when it finally reaches a `Succeeded` state. What's the correct way to model this in typespec? This is management plane.

## answer
The way this is currently modeled in swagger (and required by lintdiff rules) is that you have a 200 response that represents the eventual operation return value when the operation is resolved, like the 'move' operation in this example:
```
/** A ContosoProviderHub resource */
model Employee is TrackedResource<EmployeeProperties> {
  ...ResourceNameParameter<Employee>;
}

/** Employee properties */
model EmployeeProperties {
  /** Age of employee */
  age?: int32;

  /** City of employee */
  city?: string;

  /** Profile of employee */
  @encode("base64url")
  profile?: bytes;

  /** The status of the last operation. */
  @visibility(Lifecycle.Read)
  provisioningState?: ProvisioningState;
}

/** The provisioning state of a resource. */
@lroStatus
union ProvisioningState {
  string,

  /** The resource create request has been accepted */
  Accepted: "Accepted",

  /** The resource is being provisioned */
  Provisioning: "Provisioning",

  /** The resource is updating */
  Updating: "Updating",

  /** Resource has been created. */
  Succeeded: "Succeeded",

  /** Resource creation failed. */
  Failed: "Failed",

  /** Resource creation was canceled. */
  Canceled: "Canceled",

  /** The resource is being deleted */
  Deleting: "Deleting",
}

/** Employee move request */
model MoveRequest {
  /** The moving from location */
  from: string;

  /** The moving to location */
  to: string;
}

/** Employee move response */
model MoveResponse {
  /** The status of the move */
  movingStatus: string;
}

interface Operations extends Azure.ResourceManager.Operations {}

@armResourceOperations
interface Employees {
  /** A sample resource action that move employee to different location */
  move is ArmResourceActionAsync<Employee, MoveRequest, MoveResponse>;
}

```
 
We would like to move to a representation where the 200 response is not in the swagger and the return value is represented in the long-running-operation-options extension, but not all emitters for required languages support this yet.

# How to customize "original-uri" in arm template?

**Category: Long Running Operation(LRO)**

## question 
We have a customer who sets ["final-state-via": "original-uri"](https://github.com/Azure/azure-rest-api-specs/blob/11059b2f00c7572b276dc9862c0b41db8702cc78/specification/dashboard/resource-manager/Microsoft.Dashboard/stable/2024-10-01/grafana.json#L1007). 
```
"x-ms-long-running-operation-options": {
          "final-state-via": "original-uri"
        },
```
We have ArmAsyncOperationHeader, ArmLroLocationHeader. Seems we don't have a header for original-uri?

## answer
`original-uri` is only a valid setting for PUT operations, it means that the original URI in the PUT request is used to retrieve the resource, which has a status field that determines its state. Generally, this is the default for LRO PUT operations, but if there are multiple valid pathways to resolve the lro, you can use `@useFinalStateVia` to choose which one should be favored. like this:
```
@armResourceOperations
interface Employees {
  get is ArmResourceRead<Employee>;
  @useFinalStateVia("original-uri")
  create is ArmResourceCreateOrReplaceAsync<Employee>;
}
```
When you have multiple valid pathways to resolve the lro, you might have to use `@useFinalStateVia` to prefer one over the other.  Since this API also has an Azure-AsyncOperation header, and for ARM, looking at it the default for PUT is Azure-AsyncOperation, when it is present.

# Avocado Failing on PR

**Category: TypeSpec Validation**

## question 
Hi TypeSpec Discussion
 
I have a PR here to add a new set of Azure AI APIs: https://github.com/Azure/azure-rest-api-specs/pull/33130
 
I'm a bit confused on why the avocado step is failing? As this is a brand new API, we started from scratch with tsp itself, and these swaggers are the output of `npx tsv` .... Do I really need to include a README.md in the swagger directories, or is this just failing incorrectly? I don't see README.md files in other service directories (i.e. keyvault) for example.

## answer
you need a readme.md somewhere to generate SDKs.  location and factoring of the readme.md(s) can vary by spec.

# Need help in Adding final-state-schema for a single post action

**Category: Long Running Operation(LRO)**

## question 
Hi TypeSpec Discussion,
PR: https://github.com/Azure/azure-rest-api-specs-pr/pull/22427
 
We would like to add final-state-schema for a single post action LRO operation for now. Is it possible to do it for a single post action or not ?
 
when we add emit-lro-options: "all" in tspconfig.yml. It is reflected in all the long-running options..

## answer
So, what you need to do is the following:  Change the response type to match the final result type you want  Here is a playground showing that the response parameter in ArmResourceActionAsync shows up both in the 200 response and in the final-state-schema, which means that typespec-based emitters  will get the right final response value and so will swagger-based emitters.  
 
To be clear the final-state-schema in this case is just for debugging purposes is it not necessary in the actual swagger.  I added a comment to the PR showing the change you should make here.
 
# Typespec -> Autorest generation : multiple specs per service

**Category: SDK Generation**

## question 
Currently while we are able to organize and manage multiple typespec files per service easily, the final generated swagger is a single file.
I was asked during my API review to check if there is feasibility to produce multiple specs per service for organizational purposes considering the generated file is huge. 
I see prior posts on this indicating this is not supported, but looking for any latest update/guidance here.
Secondly, if the above is in fact supported, any idea if the SDK generation part can handle multiple specs per service?

## answer
No, since the swagger is now just an emitted artifact, there is no real reason to organize it.  There is no mechanism for splitting a TypeSpec spec into multiple OpenAPI files.

# Proper Service Versioning

**Category: Versioning**

## question 
Hi TypeSpec Discussion. I'm looking to understand how to properly add a new service version to my team's typespec. I've been looking at this doc here as a baseline, and I think I generally understand everything there. But I've got a couple of questions for my specific case.
1. What does the `added` decorator actually do? Just tell the swagger which version should/shouldn't contain a property? I'm assuming the question of whether it has an impact on any of the SDKs is a question for the individual generator teams?
2. My team's spec has a [client.tsp file](https://github.com/Azure/azure-rest-api-specs/blob/dargilco/ai-model-inference/specification/ai/ModelClient/client.tsp#L8) with a `customization` namespace, which has this decorator: `@useDependency(AI.Model.Versions.v2024_05_01_Preview)`. I get the general gist that this ties things to a specific version, but what does that mean from a practical standpoint? I maybe can understand client customizations being specific to individual versions, but what about modifications that work across versions? I don't seem to be able to provide a list or anything to that decorator. I've tried removing it, and I get an error saying that the `customization` namespace is referencing a versioned namespace and should add the decorator. I've also tried just changing the namespace to match, but then I get an error from my client interfaces saying that I have duplicate operations. So I'm trying to understand how to correctly handle this.

Any pointers would be appreciated. Thanks in advance!

## answer
On the first question, TypeSpec is allowing you to version based on differences,  starting with the base api-version, whenever you make changes to the api, you just need to tag those changes with the 'versioning' decorator to ensure that typespec can reconstruct the api at each version that is still active.
In the case of `@added` this is used whenever adding a new type to the spec - a new model, a new model property, a new interface, a new parameter, a new operation - you simply decorate the element with this decorator and pass in the version that this change occurred in.  `@removed` works similarly for removing types (which is always a breaking change).  decorators like `@renamedFrom` allow you to rename types, and take the version the change occurred at and the old name of the type (the type name is changed inline). `@typeChangedFrom` works similarly - describing the state of the type before the change occurred.
There are some limitations around versioning (for example, versioning decorators is impossible, so the decorated types themselves generally need to be versioned.
 
As far as the client.tsp goes, versioning is tightly tied to a namespace (but includes all the child namespaces).  If your client.tsp is a child namespace of the versioned namespace, then no explicit version coupling is required.  If not, then you will need to replicate the versions enum from the service namespace in client.tsp,  and explicitly tie each version to the corresponding version.  I have shown an example of what I mean:
```
import "@typespec/http";
import "@typespec/rest";
import "@typespec/versioning";
import "@azure-tools/typespec-azure-core";

using Http;
using Rest;
using Versioning;
using Azure.Core;
using Azure.Core.Traits;

@versioned(Contoso.WidgetManager.Versions)
namespace Contoso.WidgetManager {
  /** The Contoso Widget Manager service version. */
  enum Versions {
    /** Version 2022-08-30 */
    @useDependency(Azure.Core.Versions.v1_0_Preview_2)
    `2022-08-30`,

    /** Version 2025-01-30 */
    @useDependency(Azure.Core.Versions.v1_0_Preview_2)
    `2025-01-30`,
  }

  // Models ////////////////////

  /** The color of a widget. */
  union WidgetColor {
    string,

    /** Black Widget Color */
    Black: "Black",

    /** White Widget Color */
    White: "White",

    /** Red Widget Color */
    Red: "Red",

    /** Green Widget Color */
    Green: "Green",

    /** Blue Widget Color */
    Blue: "Blue",
  }

  /** A widget. */
  @resource("widgets")
  model Widget {
    /** The widget name. */
    @key("widgetName")
    @visibility(Lifecycle.Read)
    name: string;

    /** The widget color. */
    color: WidgetColor;

    /** The ID of the widget's manufacturer. */
    manufacturerId: string;

    ...EtagProperty;
  }

  /** The repair state of a widget. */
  @lroStatus
  union WidgetRepairState {
    string,

    /** Widget repairs succeeded. */
    Succeeded: "Succeeded",

    /** Widget repairs failed. */
    Failed: "Failed",

    /** Widget repairs were canceled. */
    Canceled: "Canceled",

    /** Widget was sent to the manufacturer. */
    SentToManufacturer: "SentToManufacturer",
  }

  /** A submitted repair request for a widget. */
  model WidgetRepairRequest {
    /** The state of the widget repair request. */
    requestState: WidgetRepairState;

    /** The date and time when the repair is scheduled to occur. */
    scheduledDateTime: utcDateTime;

    /** The date and time when the request was created. */
    createdDateTime: utcDateTime;

    /** The date and time when the request was updated. */
    updatedDateTime: utcDateTime;

    /** The date and time when the request was completed. */
    completedDateTime: utcDateTime;
  }

  /** The parameters for a widget status request */
  model WidgetRepairStatusParams {
    /** The ID of the widget being repaired. */
    @path
    widgetId: string;
  }

  /** A widget's part. */
  @resource("parts")
  @parentResource(Widget)
  model WidgetPart {
    /** The name of the part. */
    @key("widgetPartName")
    @visibility(Lifecycle.Read)
    name: string;

    /** The ID to use for reordering the part. */
    partId: string;

    /** The ID of the part's manufacturer. */
    manufacturerId: string;

    ...EtagProperty;
  }

  /** The details of a reorder request for a WidgetPart. */
  model WidgetPartReorderRequest {
    /** Identifies who signed off the reorder request. */
    signedOffBy: string;
  }

  // An example of a singleton resource
  /** Provides analytics about the use and maintenance of a Widget. */
  @resource("analytics")
  @parentResource(Widget)
  model WidgetAnalytics {
    /** The identifier for the analytics object.  There is only one named 'current'. */
    @key("analyticsId")
    @visibility(Lifecycle.Read)
    id: "current";

    /** The number of uses of the widget. */
    useCount: int64;

    /** The number of times the widget was repaired. */
    repairCount: int64;
  }

  /** A manufacturer of widgets. */
  @resource("manufacturers")
  model Manufacturer {
    /** The manufacturer's unique ID. */
    @key("manufacturerId")
    @visibility(Lifecycle.Read)
    id: string;

    /** The manufacturer's name. */
    name: string;

    /** The manufacturer's full address. */
    address: string;

    ...EtagProperty;
  }

  // Operations ////////////////////

  /** The service traites */
  model ServiceTraits {
    ...SupportsRepeatableRequests;
    ...SupportsConditionalRequests;
    ...SupportsClientRequestId<Versions.`2025-01-30`>;
  }

  alias Operations = Azure.Core.ResourceOperations<ServiceTraits>;
}

@useAuth(
  ApiKeyAuth<ApiKeyLocation.header, "api-key"> | OAuth2Auth<[
    {
      type: OAuth2FlowType.implicit,
      authorizationUrl: "https://login.contoso.com/common/oauth2/v2.0/authorize",
      scopes: ["https://widget.contoso.com/.default"],
    }
  ]>
)
@service(#{ title: "Contoso Widget Manager" })
@server(
  "{endpoint}/widget",
  "Contoso Widget APIs",
  {
    /** 
Supported Widget Services endpoints (protocol and hostname, for example:
https://westus.api.widget.contoso.com).
 */
    endpoint: string,
  }
)
@versioned(Versions)
namespace ContosoOperations {
  using Contoso.WidgetManager;

  interface Widgets {
    // Operation Status
    /** Gets status of a Widget operation. */
    @sharedRoute
    getWidgetOperationStatus is Operations.GetResourceOperationStatus<Widget>;
    /** Gets status of a Widget delete operation. */
    @sharedRoute
    getWidgetDeleteOperationStatus is Operations.GetResourceOperationStatus<
      Widget,
      never
    >;

    // Widget Operations
    /** Creates or updates a Widget asynchronously */
    @pollingOperation(Widgets.getWidgetOperationStatus)
    createOrUpdateWidget is Operations.LongRunningResourceCreateOrUpdate<Widget>;

    /** Get a Widget */
    getWidget is Operations.ResourceRead<Widget>;

    /** Delete a Widget asynchronously. */
    @pollingOperation(Widgets.getWidgetDeleteOperationStatus)
    deleteWidget is Operations.LongRunningResourceDelete<Widget>;

    /** List Widget resources */
    listWidgets is Operations.ResourceList<
      Widget,
      ListQueryParametersTrait<StandardListQueryParameters &
        SelectQueryParameter>
    >;

    // Widget Analytics
    /** Get a WidgetAnalytics */
    getAnalytics is Operations.ResourceRead<WidgetAnalytics>;

    /** Creates or updates a WidgetAnalytics */
    updateAnalytics is Operations.ResourceCreateOrUpdate<WidgetAnalytics>;

    // Widget Repair Operations
    /** Get the status of a WidgetRepairRequest. */
    #suppress "@azure-tools/typespec-azure-core/use-standard-operations" "This is a custom operation status endpoint."
    @route("/widgets/{widgetId}/repairs/{operationId}")
    getRepairStatus is Foundations.GetOperationStatus<
      WidgetRepairStatusParams,
      WidgetRepairRequest
    >;

    /** Schedule a widget for repairs. */
    @pollingOperation(Widgets.getWidgetOperationStatus)
    scheduleRepairs is Operations.LongRunningResourceAction<
      Widget,
      WidgetRepairRequest,
      WidgetRepairRequest & RequestIdResponseHeader
    >;
  }

  interface WidgetParts {
    /** Gets status of a WidgetPart operation. */
    getWidgetPartOperationStatus is Operations.GetResourceOperationStatus<WidgetPart>;

    /** Creates a WidgetPart */
    createWidgetPart is Operations.ResourceCreateWithServiceProvidedName<WidgetPart>;

    /** Get a WidgetPart */
    getWidgetPart is Operations.ResourceRead<WidgetPart>;

    /** Delete a WidgetPart */
    deleteWidgetPart is Operations.ResourceDelete<WidgetPart>;

    /** List WidgetPart resources */
    listWidgetParts is Operations.ResourceList<WidgetPart>;

    /** Reorder all parts for the widget. */
    @pollingOperation(WidgetParts.getWidgetPartOperationStatus)
    reorderParts is Operations.LongRunningResourceCollectionAction<
      WidgetPart,
      WidgetPartReorderRequest,
      never
    >;
  }

  interface Manufacturers {
    /** Gets status of a Manufacturer operation. */
    getManufacturerOperationStatus is Operations.GetResourceOperationStatus<Manufacturer>;

    /** Creates or replaces a Manufacturer */
    createOrReplaceManufacturer is Operations.ResourceCreateOrReplace<Manufacturer>;

    /** Get a Manufacturer */
    getManufacturer is Operations.ResourceRead<Manufacturer>;

    /** Delete a Manufacturer asynchronously. */
    @pollingOperation(Manufacturers.getManufacturerOperationStatus)
    deleteManufacturer is Operations.LongRunningResourceDelete<Manufacturer>;

    /** List Manufacturer resources */
    listManufacturers is Operations.ResourceList<Manufacturer>;
  }

  /** The Contoso Widget Manager service version. */
  enum Versions {
    /** Version 2022-08-30 */
    @useDependency(Azure.Core.Versions.v1_0_Preview_2)
    @useDependency(Contoso.WidgetManager.Versions.`2022-08-30`)
    `2022-08-30`,

    /** Version 2025-01-30 */
    @useDependency(Azure.Core.Versions.v1_0_Preview_2)
    @useDependency(Contoso.WidgetManager.Versions.`2025-01-30`)
    `2025-01-30`,
  }
  // A "global" RPC operation
  /** Responds with status information about the overall service. */
  @route("service-status")
  op getServiceStatus is RpcOperation<
    {},
    {
      statusString: string;
    },
    ServiceTraits
  >;
}
```
Feel free to reach out with any specific questions.
The linked playground is a little more complex than it needs to be, but, depending on what is in your client.tsp, is likely similar.  Note that this also gives you the option of making version-specific client.tsp changes, but simply having the linkage as shown using the `@useDependency` decorators will ensure that the client.tsp is used in both versions.
 
# JSON merge-patch support in TypeSpec

**Category: Patch**

## question 
How exactly does TypeSpec support `application/merge-patch+json` i.e., "JSON merge-patch"? Is there explicit types, or is it really just a matter of service authors adding `| null` to their type defs e.g.,

```
model M {
    @key("id")
    id: string;
    name: string | null;
    dob?: utcDateTime | null;
}
```
This will greatly affect how Rust will support this, give a discussion Larry, Johan, and I were having yesterday.

## answer
Currently, TypeSpec does **not** have built-in or explicit support for `application/merge-patch+json` (JSON Merge Patch). That means there are no dedicated keywords or types in the language to model it directly.

The current recommended approach is to **manually define a separate PATCH model** for each resource. This model should mirror the resource structure, but all properties should be made optional. This expresses the correct merge-patch behavior where only specified fields are updated.

Importantly, we **do not use `| null` in the model to indicate erasable fields**. Just like in Azure and Graph, we treat merge-patch support as a **fundamental protocol decision of the service**, not something that should be reflected in the type system. In other words, the ability to pass `null` is not encoded in the TypeSpec models today.

That said, we recognize that for generation-first languages like Rust, it's essential to know whether a field can explicitly be `null` versus being omitted. To address this, we're currently designing a new **`MergePatch` template**, which will help service authors more easily generate accurate merge-patch OpenAPI schemas. It will also make it possible for emitters to trace a merge-patch model back to its original resource definition.

# How to make an interface internal ?

**Category: SDK Generation**

## question 
I am looking for ways to make an interface internal so that it does not appear in public interface of python SDK. This is the interface which emits `EvaluationResultsOperations` which shows up on client. I would like to generate it but keep it hidden from public interface.
 
I tried following:
1. Mark all operations under it internal
2. Adding @access decorator to interface but that fails.

Is there a way to achieve it ?

## answer
If your goal is to **hide an operations interface from the public Python SDK surface**, here's the key takeaway:

> **We currently do not support hiding an entire operation group directly.**

However, there are **two main approaches** to achieve your intent:

1. **Use `client.tsp` to redefine your client** and control which operations appear on the public client. When you redefine the client structure this way, **default service clients (and their `Operations` classes) should not be emitted**—as long as there’s no leftover generated code from a previous run. Make sure to:

   * Remove all previously generated SDK output before regenerating.
   * Verify your custom client structure is complete.

2. **Use `_patch.py` to customize visibility**, e.g., by renaming `client.evaluation_results` to `client._evaluation_results`, if needed. This is a workaround until more flexible TypeSpec features are available.

> Also, note that the `@access` decorator doesn’t work on interfaces right now—it’s not interpreted that way by the client generator (tcgc).

So, the current best practice is to **redefine the client properly in `client.tsp`**, clean your generated code, and regenerate to reflect the changes accurately.
 
# Sharing models between data plane and control plane

**Category: Versioning**

## question 
Has anyone successfully shared models between control plane and data plane? I'm struggling with this seemingly simple task and could use come guidance or an example other than the trivial one for sharing a TSP file withing control plan or within data plane for a single service.
 
Even to share models across separate versioned data plane APIs, I ended up creating a new data plane shared namespace and associated version to get it working. Do I need to create a control plane shared namespace and version? This makes me a bit nervous about conflicting versions of the same dependency between the service namespace, data plane shared namespace and control plane shared namespace.
 
When I try to cross data plane and control plane TypeSpec, I end up with unhelpful errors like this:
```
<unknown location>:1:1 - error @typespec/versioning/using-versioned-library: Namespace '' is referencing types from versioned namespace 'Azure.Core' but didn't specify which versions with @useDependency.
<unknown location>:1:1 - error @typespec/versioning/using-versioned-library: Namespace '' is referencing types from versioned namespace 'Azure.ResourceManager' but didn't specify which versions with @useDependency.
```
Or errors about multiple namespace or about @service not specifying a namespace even though it does.

## answer
Yes, you **can share models** between data plane and control plane, but you need to be careful:

* ✅ **Create a shared namespace** (e.g., `Discovery.Shared`) that’s not tied to either control or data plane.
* ✅ **Version the shared types independently**, not tied to any API version.
* ✅ **Avoid ARM library dependencies in data plane** — model things like resource IDs using aliases or common types.
* ✅ Use `@useDependency` to reference versioned namespaces like `Azure.Core` or `Azure.ResourceManager`.

This way, you can safely reuse types without introducing versioning conflicts or unwanted dependencies.


# Question regarding the unexpected readonly, and customize the enum name

**Category: TypeSpec Migration**

## question 
Hi team,
 
When dealing with the TypeSpec migration, we hit below two issues. Could you help take a look and see if there is any way to fix them? Thanks!
1. Haven't add @visibility(Lifecycle.Read) to the property, but the definition has "readOnly": true on it.
- TSP: https://github.com/Azure/azure-rest-api-specs/blob/45317772ce7c50313eaf55b8d242f4d12ca6fe06/specification/desktopvirtualization/DesktopVirtualization.Management/models.tsp#L3665
`updateState?: UpdateState;`
Swagger: https://github.com/Azure/azure-rest-api-specs/blob/45317772ce7c50313eaf55b8d242f4d12ca6fe06/specification/desktopvirtualization/resource-manager/Microsoft.DesktopVirtualization/preview/2025-04-01-preview/desktopvirtualization.json#L11380
`"readOnly": true`
- TSP: https://github.com/Azure/azure-rest-api-specs/blob/45317772ce7c50313eaf55b8d242f4d12ca6fe06/specification/desktopvirtualization/DesktopVirtualization.Management/models.tsp#L4859
`status: SessionHostManagementUpdateOperationStatus;`
Swagger: https://github.com/Azure/azure-rest-api-specs/blob/45317772ce7c50313eaf55b8d242f4d12ca6fe06/specification/desktopvirtualization/resource-manager/Microsoft.DesktopVirtualization/preview/2025-04-01-preview/desktopvirtualization.json#L10826
`"readOnly": true`
2. How to make enum's "x-ms-enum" name to be different than the type name like below?
- https://github.com/Azure/azure-rest-api-specs/blob/cb262725d128f6dfec4622cca03bc9e04e2d0f1f/specification/desktopvirtualization/resource-manager/Microsoft.DesktopVirtualization/preview/2024-11-01-preview/desktopvirtualization.json#L9487C4-L9493C33
```
 "ScalingMethodType": {
      "enum": [
        "PowerManage",
        "CreateDeletePowerManage"
      ],
      "x-ms-enum": {
        "name": "ScalingMethod",
```

## answer
1. This is because of this https://azure.github.io/typespec-azure/docs/troubleshoot/status-read-only-error/#_top
2. No its not possible change the enum name to be what is in `x-ms-enum.name` it is pointless information otherwise
 
# Discrepancy in the original LRO response and Status Monitor Response

**Category: Long Running Operation(LRO)**

## question 
Hi TypeSpec Discussion team,
 
We have created a long running resource action on our dataplane resource and have created a common status monitor endpoint (`operations/{operationId}`). Now the default status monitor response for the LRO comes out to be :
```
{
    "id": "",
    "status": ""
    "error": ""
}
```
However, following standard resource conventions for the status monitor, the LRO for it comes out to be : 
```
{
    "operationId": "",
    "status": "",
    "kind": ""
    "error": ""
}
```
Given this, how can I change the response of our Long Running Action defined? 
 
```
@useAuth(
  ApiKeyAuth<ApiKeyLocation.header, "api-key"> | OAuth2Auth<[
    {
      type: OAuth2FlowType.implicit,
      authorizationUrl: "https://login.contoso.com/common/oauth2/v2.0/authorize",
      scopes: ["https://widget.contoso.com/.default"],
    }
  ]>
)
@service(#{ title: "Contoso Widget Manager" })
@server(
  "{endpoint}/widget",
  "Contoso Widget APIs",
  {
    /** 
Supported Widget Services endpoints (protocol and hostname, for example:
https://westus.api.widget.contoso.com).
 */
    endpoint: string,
  }
)
@versioned(Contoso.WidgetManager.Versions)
namespace Contoso.WidgetManager;

/** The Contoso Widget Manager service version. */
enum Versions {
  /** Version 2022-08-31 */
  @useDependency(Azure.Core.Versions.v1_0_Preview_2)
  `2022-08-30`,
}

// Models ////////////////////

/** The color of a widget. */
union WidgetColor {
  string,

  /** Black Widget Color */
  Black: "Black",

  /** White Widget Color */
  White: "White",

  /** Red Widget Color */
  Red: "Red",

  /** Green Widget Color */
  Green: "Green",

  /** Blue Widget Color */
  Blue: "Blue",
}

/** A widget. */
@resource("widgets")
model Widget {
  /** The widget name. */
  @key("widgetName")
  @visibility(Lifecycle.Read)
  name: string;

  /** The widget color. */
  color: WidgetColor;

  /** The ID of the widget's manufacturer. */
  manufacturerId: string;

  ...EtagProperty;
}

@doc("Operation Id Path Parameter.")
model OperationIdPathParameter {
  @doc("The unique ID of the operation.")
  @key
  @visibility(Lifecycle.Read)
  operationId: string;
}

@doc("Kind of the long running operation.")
union OperationKind {
  string,

  @doc("Operation represents a clone widget operation")
  CloneWidget: "CloneWidget",
}

@doc("Status of a long running operation.")
@resource("operations")
model OperationStatus {
  @doc("The state of the operation.")
  status: Foundations.OperationState;

  @doc("The kind of the operation.")
  kind: OperationKind;

  @doc("Error object that describes the error when status is \"Failed\".")
  error?: Foundations.Error;

  ...OperationIdPathParameter;
}

model cloneWidgetRequest {
  newWidgetId?: string;
}

// Operations ////////////////////

alias ServiceTraits = SupportsRepeatableRequests &
  SupportsConditionalRequests &
  SupportsClientRequestId;

alias Operations = Azure.Core.ResourceOperations<ServiceTraits>;

interface LrOperations {
  getOperationStatus is StandardResourceOperations.ResourceRead<OperationStatus>;
}

interface Widgets {

  /** Get a Widget */
  getWidget is Operations.ResourceRead<Widget>;

  /** Clone a widget */
  @pollingOperation(LrOperations.getOperationStatus)
  @finalOperation(Widgets.getWidget)
  @action("clone")
  cloneWidget is StandardResourceOperations.LongRunningResourceAction<Widget, cloneWidgetRequest, never>;

}
```

## answer
A notice on Guideline on LRO, the "id" of the status monitor should be "id", not "operationId"
https://github.com/microsoft/api-guidelines/blob/vNext/azure/ConsiderationsForServiceDesign.md#long-running-action-operations
To ensure its called {operationId} in the route template but id in the response object, I think you can use this
```
  @key("operationId")
  @visibility(Lifecycle.Read)
  id: string;
```

# Visibility-sealed error while validating locally

**Category: TypeSpec Validation**

## question 
I am getting this error while running `npx tsv` locally:
```
error visibility-sealed: Visibility of property 'name' is sealed and cannot be changed.
> 155 | @Azure.ResourceManager.Private.armResourceInternal(FileSystemResourceProperties)
```
I tried removing the visibility decorator for the field/property 'name', but still the error was coming.
How do I resolve this?
Package version details:
```
"@typespec/compiler": "0.67.2",
"@typespec/http": "0.67.1",
"@typespec/sse": "0.67.1",
"@typespec/events": "0.67.1",
"@typespec/openapi": "0.67.1",
"@typespec/openapi3": "0.67.1",
"@typespec/prettier-plugin-typespec": "0.67.1",
"@typespec/rest": "0.67.1",
"@typespec/streams": "0.67.1",
"@typespec/versioning": "0.67.1",
"@typespec/xml": "0.67.1",
```
The relevant typespec file:
```
import "./../LiftrBase/main.tsp";

import "@typespec/openapi";
import "@typespec/http";
import "@typespec/rest";
import "@typespec/versioning";

using Azure.ResourceManager;
using LiftrBase;
using TypeSpec.Http;
using TypeSpec.OpenAPI;
using TypeSpec.Rest;
using TypeSpec.Versioning;
using TypeSpec.Reflection;
using Azure.ResourceManager.Foundations;

@versioned(LiftrBase.Storage.Versions)
@armLibraryNamespace
namespace LiftrBase.Storage;

@doc("Supported versions for LiftrBase.Storage resource model")
enum Versions {
  @doc("Dependent on Azure.ResourceManager.Versions.v1_0_Preview_1 and LiftrBase.Versions.v1_preview")
  @useDependency(Azure.ResourceManager.Versions.v1_0_Preview_1)
  @useDependency(LiftrBase.Versions.v2_preview)
  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v3)
  v2_preview: "2024-02-01-preview",
}

/**
 * Properties specific to the Qumulo File System resource
 */
model FileSystemResourceProperties {
  /**
   * Marketplace details
   */
  marketplaceDetails: MarketplaceDetails;

  /**
   * Provisioning State of the resource
   */
  @visibility(Lifecycle.Read)
  provisioningState?: ProvisioningState;

  /**
   * Storage Sku
   */
  storageSku: string;

  /**
   * User Details
   */
  userDetails: UserDetails;

  /**
   * Delegated subnet id for Vnet injection
   */
  delegatedSubnetId: string;

  /**
   * File system Id of the resource
   */
  clusterLoginUrl?: string;

  /**
   * Private IPs of the resource
   */
  #suppress "@azure-tools/typespec-azure-core/casing-style" "This is the correct name"
  privateIPs?: string[];

  /**
   * Initial administrator password of the resource
   */
  @extension("x-ms-secret", true)
  adminPassword: string;

  /**
   * Availability zone
   */
  availabilityZone?: string;
}

/**
 * Common fields that are returned in the response for all Azure Resource Manager resources
 */
model Resource {
  /**
   * Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
   */
  @visibility(Lifecycle.Read)
  id?: string;

  /**
   * The name of the resource
   */
  @visibility(Lifecycle.Read)
  name?: string;

  /**
   * The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
   */
  @visibility(Lifecycle.Read)
  type?: string;

  /**
   * Azure Resource Manager metadata containing createdBy and modifiedBy information.
   */
  @visibility(Lifecycle.Read)
  systemData?: SystemData;
}

/**
 * The type used for update operations of the FileSystemResource.
 */
model FileSystemResourceUpdate {
  /**
   * The managed service identities assigned to this resource.
   */
  identity?: Azure.ResourceManager.CommonTypes.ManagedServiceIdentity;

  /**
   * Resource tags.
   */
  tags?: Record<string>;

  /**
   * The updatable properties of the FileSystemResource.
   */
  properties?: FileSystemResourceUpdateProperties;
}

/**
 * The updatable properties of the FileSystemResource.
 */
model FileSystemResourceUpdateProperties {
  /**
   * Marketplace details
   */
  marketplaceDetails?: MarketplaceDetails;

  /**
   * User Details
   */
  userDetails?: UserDetails;

  /**
   * Delegated subnet id for Vnet injection
   */
  delegatedSubnetId?: string;
}

#suppress "@azure-tools/typespec-azure-core/composition-over-inheritance" "For backward compatibility"
#suppress "@azure-tools/typespec-azure-resource-manager/arm-resource-invalid-envelope-property" "For backward compatibility"
@Http.Private.includeInapplicableMetadataInPayload(false)
@Azure.ResourceManager.Private.armResourceInternal(FileSystemResourceProperties)
model FileSystemResource
  is Azure.ResourceManager.TrackedResource<FileSystemResourceProperties> {
  /**
   * Name of the File System resource
   */
  @path
  @key("fileSystemName")
  @segment("fileSystems")
  @visibility(Lifecycle.Read)
  @pattern("^[a-zA-Z0-9_-]*$")
  name: string;

  ...Azure.ResourceManager.ManagedServiceIdentityProperty;
}
```

## answer
I believe this occurs because  the `TrackedResource` template already has the @Azure.ResourceManager.Private.armResourceInternal decorator applied, and using the model is, you are including both decorators in that type.  Based on the suppression you also have there on 'composition-over-inheritance', my guess s that this type previouslu used `FileSystemResource extends TrackedResource<FileSystemProperties>`  in this case, the decorator from TrackedResource<T>  would not be applied.
The solution would be to remove the `armResourceInternal`  decorator here, because it is redundant

# Annotate same model with SubscriptionLocationResource and ResourceGroupLocationResource

**Category: Arm Resource Manager(ARM) Template**

## question 
1. We have added a new SubscriptionLocationResource named "ValidatedSolutionRecipe", as per the typespec docs to our RP - Microsoft.AzureStackHCI. Here is the typespec for this resource
2. This is a proxy resource and the URL path for this resource looks like "/subscriptions/921d26b3-c14d-4efc-b56e-93a2439e028c/providers/Microsoft.AzureStackHCI/locations/eastus/validatedSolutionRecipes/10.2502.0?api-version=2023-12-01-preview"
As above API is a subscription level API, the clients of the API need to have subscription level RBAC. Due to security requirements, we need to have a similar API, but at resource group scope.
1. From the typespec docs and our prototyping, we see that we can achieve this by havning a ResourceGroupLocationResource.
2. However, same model in typespec can't be annotated with both SubscriptionLocationResource and ResourceGroupLocationResource. When we do so, the generated swagger only has either subscription level paths or resourcegroup level paths, depending on which annotation is first on the model.
3. Thus, to work around this, we had to introduce a new resource type with an undesirable name - "ResourceGroupValidatedSolutionRecipe".
But it is the same resource. Just because of the limitation of not being able to support both [SubscriptionLocationResource](https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/data-types/#Azure.ResourceManager.SubscriptionLocationResource) and [ResourceGroupLocationResource](https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/data-types/#Azure.ResourceManager.ResourceGroupLocationResource), we have to create a new model with an undesirable name - "ResourceGroupValidatedSolutionRecipe".
 
Please help us and let us know how can we utilize the model with same name (i.e. the same resource type) for both of the above APIs.

## answer
he main issue is that TypeSpec does not support annotating the same model with both SubscriptionLocationResource and ResourceGroupLocationResource. This leads to the creation of two different models (e.g., ValidatedSolutionRecipe and ResourceGroupValidatedSolutionRecipe), even though they represent the same resource. According to ARM requirements, these resources must be registered as two different types because they have different scopes and operations.

Solution:
Shared Model: If the operations for both resources are identical, you can consider using custom operations to share the same model, avoiding the need to create two different resource types.

RPaaS Proxy Resources: By using RPaaS extensions, you can handle this scenario and simplify the API, reducing confusion for customers.

In summary, although the resources may represent the same entity, due to ARM registration requirements and operational differences, two models may be necessary. However, using custom operations or extension resource patterns can help avoid redundant model creation in certain cases.

# Support for @includeInapplicableMetadataInPayload decorator

**Category: Decorators**

## question 
After pulling the latest changes, I been getting errors regarding "@includeInapplicableMetadataInPayload(false)" decorator not being supported anymore.
 
Is it not possible to make use of the decorator? If I removed the decorator from the model ts file, it changes the expected model definition for the API path on swagger.

## answer
The issue is related to the deprecation of the @includeInapplicableMetadataInPayload(false) decorator in TypeSpec version 0.67. It has been moved to a private namespace, and you can still use it, but with a warning.
Decorator Usage: You can still use the @includeInapplicableMetadataInPayload decorator, but it will trigger a warning since it's now in a private namespace.

Breaking Change: Removing this decorator causes a breaking change for existing API versions because the Swagger model definition is altered.

Suggestion: The team suggests not relying on the decorator and using existing resource models like TrackedResource<T> instead.

# Type Spec review for Data plane API specs

**Category: SDK Generation**

## question 
Hi TypeSpec Discussion, do we need review from type spec team before we could merge data plane API spec PR on github specs repo?

## answer
All data plane API specs must be reviewed by the API Stewardship board.  Please create a release plan and then you can schedule a review.  [What is a release plan](https://eng.ms/docs/products/azure-developer-experience/plan/release-plan)?
```
What is a release plan?
A release plan is a guided workflow that you can create to track an upcoming REST API and SDK release.

How it works
Let's say your product team is working towards a new feature or REST API version. With Release Planner, you can build a guided workflow for the REST API and SDK tasks that your team must complete to obtain Cloud Product Excellence (CPEX) sign-off.

For example, consider the following scenario:

As an Azure service engineer, you want to know what tasks are required to release a new REST API version to customers. You log in to Release Planner and create new plan.
Release Planner connects to Service Tree to get details about your service, and creates a workflow that's specific to your scenario.
You link the pull request that contains your latest REST API spec updates. Release Planner lets you know when it's time to schedule a review, fix validation issues, request sign-offs, and more.
You then get information on how to generate, test, release, and get approval of your SDKs.
Milestones and tasks
A release plan consists of milestones. A milestone is a bucket of related tasks to complete. Depending on your product's specific scenario, the milestones and tasks will vary. The major two milestones are API Readiness and SDK release
```

# What is `x-ms-long-running-operation-options` for LRO operation of data-plane when `emit-lro-options: none` in `@azure-tools/typespec-autorest`?

**Category: Long Running Operation(LRO)**

## question 
Many `tspconfig.yaml` files for data-plane have an option `emit-lro-options: none` for emitter `@azure-tools/typespec-autorest`, which means only emit `x-ms-long-running-operation` but does not emit`x-ms-long-running-operation-option` for resource providers, like the following loadtestservice `tspconfig.yaml`: [azure-rest-api-specs/specification/loadtestservice/LoadTestService/tspconfig.yaml at main · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/loadtestservice/LoadTestService/tspconfig.yaml#L24)
```
parameters:
  service-dir:
    default: "sdk/loadtesting"
  "service-name":
    default: "loadtesting"
emit:
  - "@azure-tools/typespec-autorest"
  # Uncomment this line and add "@azure-tools/typespec-python" to your package.json to generate Python code
  #- "@azure-tools/typespec-python"
  #- "@azure-tools/typespec-ts"
  #- "@azure-tools/typespec-csharp"
  # Uncomment this line and add "@azure-tools/typespec-java" to your package.json to generate Java code
  # "@azure-tools/typespec-java": true
  # Uncomment this line and add "@azure-tools/typespec-csharp" to your package.json to generate C# code
  # "@azure-tools/typespec-csharp": true
  # Uncomment this line and add "@azure-tools/typespec-ts" to your package.json to generate Typescript code
  # "@azure-tools/typespec-ts": true
linter:
  extends:
    - "@azure-tools/typespec-azure-rulesets/data-plane"
options:
  "@azure-typespec/http-client-csharp":
    namespace: Azure.Developer.LoadTesting
    model-namespace: false
  "@azure-tools/typespec-autorest":
    emitter-output-dir: "{project-root}/../"
    output-file: "{azure-resource-provider-folder}/{service-name}/{version-status}/{version}/loadtestservice.json"
    azure-resource-provider-folder: "data-plane"
    emit-lro-options: "none"
    omit-unreachable-types: true
  "@azure-tools/typespec-python":
    package-dir: "azure-developer-loadtesting"
    namespace: "azure.developer.loadtesting"
    generate-test: true
    generate-sample: true
    package-mode: azure-dataplane
    flavor: azure
  "@azure-tools/typespec-ts":
    package-dir: "load-testing-rest"
    title: Azure Load Testing
    description: Azure Load Testing Client
    generate-metadata: true
    generate-test: false
    package-details:
      name: "@azure-rest/load-testing"
      description: "This package contains Microsoft Azure LoadTestingClient client library."
      version: 1.0.1
    flavor: azure
  "@azure-tools/typespec-csharp":
    package-dir: "Azure.Developer.LoadTesting"
    clear-output-folder: true
    namespace: "{package-dir}"
    generate-sample-project: false
    model-namespace: false
    flavor: azure
  "@azure-tools/typespec-java":
    package-dir: "azure-developer-loadtesting"
    namespace: com.azure.developer.loadtesting
    enable-sync-stack: true
    partial-update: true
    generate-tests: false
    generate-samples: false
    service-name: Load Test
    flavor: azure
```

So what exactly does this data-plane operation use when polling LRO request then? Can someone explain a little more about this situation of `emit-lro-options: none`? thanks

## answer
This is just an emitter option for emission of OpenAPI from the spec.  It doesn't impact how other emitters view the LRO - the LRO is resolved based on the encoding of the operation.
 
Because it's nice to have a visual indicator that the lro is encoded correctly, it is highly encouraged that spec authors use no emit-lro-options seting, , or use `emit-lro-options: "all"` to check .  But this is not required for check-in, because the lro-options are a microsoft-specific extension with little or no documentary value to customers.

We don't generate data plane clients from OpenAPI if there is a corresponding TypeSpec, they are generated form TypeSpec directly.

# Why does the PR bot add the `WaitForARMFeedback` label when TypeSpec validation pipeline fails?

**Category: TypeSpec Validation**

## question 
Hi, not a typespec question per se, but I am curious why the PR bot now adds the WaitForARMFeedback label even when required checks fail? If I'm remembering correctly, this didn't used to be the case.
 
And now that it does add the label, it seems like the reviewer will typically manually say "Fix X pipeline check." and then switch it to "ARMChangesRequested".
 
Would it be possible for that to happen automatically? I feel bad for wasting the reviewer's time if I don't sit around and wait for the pipeline to fail and then manually remove the label myself. 
 
Or is the expectation that a commit shouldn't be pushed if I think the required checks may fail?

## answer
The WaitForARMFeedback label being added even when required checks fail is intended behavior and has always worked this way, according to the ARM review team.

Ideally, contributors should open a draft PR first and only mark it "ready for review" after all required checks pass. This avoids wasting reviewer time.

The suggestion to automatically change the label to ARMChangesRequested when checks fail is a good idea and is already on the backlog.

The engineering team is currently migrating the labeling system to GitHub Actions, which should make improvements like this easier in the future.

# Is path case sensitive?

**Category: Operations**

## question

I have these swaggers paths:
 
```
"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ElasticSan/elasticSans/{elasticSanName}/volumeGroups"
"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ElasticSan/elasticSans/{elasticSanName}/volumegroups/{volumeGroupName}"
```
The second path represents a resource like
```
model VolumeGroup
  is Azure.ResourceManager.ProxyResource<VolumeGroupProperties> {
  ...ResourceNameParameter<
    Resource = VolumeGroup,
    KeyName = "volumeGroupName",
    SegmentName = "volumegroups",
    NamePattern = "^[A-Za-z0-9]+((-|_)[a-z0-9A-Z]+)*$"
  >;
 ```
Pay attention to segment is volumegroups. 
 
The first path is a list operation to this resource. However, its last segment is volumeGroups. If I use ArmResourceListByParent<VolumeGroup> for the first path it produces volumegroups. Can I use it?

## answer
static segments in ARM urls are meant to be case-insensitive.  In this case, the swagger is incorrect, since this is clearly meant to be the ARM type name.  You should use the correct type name in both cases.

If the url is /subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/..., is that the same as `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/...? The "G" in resourceGroups has different cases.
These are case insensitive,  we should favor the camel case here, there is no need to match the exact casing of these in existing swagger.

# Discriminators/polymorphism

**Category: Decorators**

## question
I'm looking into introducing polymorphism into one of our APIs. This question provides great insight but is apparently closed as a duplicate of an issue that does not seem exist. Mark Cowlishaw, do you know what the outcome of this no longer existent issue? 
 Note that there is an issue around how we should encourage types using extends in Azure APIs to use discriminators here: https://github.com/Azure/typespec-azure-pr/issues/3510
issue content:
```
title: Add linter to guide to use composition instead of extension when the base type is not used in service

content:
When a base type is not used in the service ( which mean it is not used in any operation or model property), it does not need to define the model hierarchy via extends, it is better to define in composition way via spread or is
e.g.

model A {
  id: string;
}

model B extends A{
  name: string;
}

@route("/get")
@get
@convenientAPI(true)
op get(@body input: B): void;

The Model A is not used in the service, the purpose of model A is to construct model B, in that way, the best way is to define B in composition way via is or spread as following:

model A {
  id: string;
}

model B{
  ...A;
  name: string;
}

@route("/get")
@get
@convenientAPI(true)
op get(@body input: B): void;

or

model A {
  id: string;
}

model B is A{
  name: string;
}

@route("/get")
@get
@convenientAPI(true)
op get(@body input: B): void;

Add a warning linter rule to reject extends and guide to use composition (spread or is).
```
Like Brian Terlson,  I tend to favor the union approach for operations:
 op create(@body body: Cat | Dog // replace the base class with union of subs)
Is this the recommended Azure approach, union (i.e. @body: SubModel1 | SubModel2 for operation with @discriminator in base model type for @body ?

## answer
Azure recommends using @discriminator to model polymorphism, but there are still some missing pieces before discriminated union types will be allowed in Azure APIs. The polymorphism in the model looks correct, and it is suggested to use PascalCase for union variant names. Additionally, narrowing inherited property types in inheriting classes (except for the discriminator) is not allowed. 

# Folder structure recommendation for typespec.

**Category: SDK Generation**

## question
Hi Team,
 
Can you please confirm what the folder structure needs to be for the .tsp files, specifically for teams that are separating services within the same RP namespace?

## answer
1. Service Folder Naming:

Each service should reside in its own folder under the RP namespace.
Use PascalCase for RP namespace folders (e.g., Language, Vision).
Service folders should be singular and lowercase (e.g., TextAnalytics, ComputerVision).
2. Shared Libraries:

If multiple services share models or utilities, create a Shared folder at the same level as the services.
Example:
-> specification
   -> cognitiveservices
      -> Language.TextAnalytics
      -> Language.QnA
      -> Language.Shared
      -> Vision.ComputerVision
      -> Vision.CustomVision
      -> Vision.Shared
3. Required Files in Each Service Folder:

tspconfig.yaml: Configuration for emitters and SDK generation.
main.tsp: Entry point for the TypeSpec definitions.
Supporting *.tsp files: For models, operations, etc.
examples/: Folder with example JSON files.
4. SDK Generation:

Only services intending to generate SDKs should include emitter configuration in tspconfig.yaml.
Shared libraries should not include tspconfig.yaml.
5. No package.json in Service Folder:

Use the root-level package.json for dependencies like @azure-tools/typespec-autorest.
This structure ensures modularity and clarity when multiple services coexist under a single RP namespace, while also supporting shared components and SDK generation workflows.

Let me know if you’d like help drafting a sample folder layout or tspconfig.yaml for your team.

# Is there way to change property from required to optional?

**Category: Versioning**

## question
Hi, dear, I am working releasing video translation GA API with new version.
And we want to change a property from required to optional in the new version.
 
Previously we have a required property: sourceLocale: localeName
(Here localeName is a defined as: scalar localeName extends string;)
And now we want to change the property to optional: sourceLocale?: localeName
 
Is there anyway I can do to make the change for the new version?
 
I have tried this but doesn't work:
@doc("Translation input.")
model TranslationInput {
  @typeChangedFrom(ApiVersions.v2024_05_20_preview, localeName)
  sourceLocale?: localeName;
}
 
Could anyone help please?

## answer
use the @madeOptional decorator like this, but it will be considered a breaking change.
```
@doc("Translation input.")
model TranslationInput {
  @typeChangedFrom(ApiVersions.v2024_05_20_preview, localeName)
  @madeOptional
  sourceLocale?: localeName;
}
```